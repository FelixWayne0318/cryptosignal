# CryptoSignal v6.6 数据更新时间表

**创建时间**: 2025-11-03
**目的**: 详细说明所有数据（CVD、订单簿、6A+4B因子）的更新时机

---

## 📊 数据更新总览

| 数据类型 | 更新频率 | 更新方式 | 所属层级 | 耗时 |
|---------|---------|---------|---------|------|
| **K线价格** | 每次扫描 | Layer 1 | 实时 | 0.2秒 |
| **CVD数据** | 跟随K线 | 从K线计算 | 实时 | 即时 |
| **完整K线** | 智能触发 | Layer 2 | 准实时 | 8-15秒 |
| **订单簿** | **仅初始化** | 初始化时 | 缓存 | 20-30秒 |
| **资金费率** | 每30分钟 | Layer 3 | 定时 | 20-30秒 |
| **持仓量** | 每30分钟 | Layer 3 | 定时 | 20-30秒 |
| **现货价格** | 每次扫描 | 实时获取 | 实时 | <1秒 |

---

## 🔍 详细更新机制

### 1. CVD（累积成交量差）数据

#### 是什么？
```
CVD = Cumulative Volume Delta
累积成交量差 = Σ(买入量 - 卖出量)

用途：C因子（Capital Flow 资金流）的核心数据
```

#### 从哪里来？
```python
# CVD从K线数据中实时计算
def cvd_from_klines(klines):
    for kline in klines:
        taker_buy = kline[9]    # 主动买入量
        total_vol = kline[5]    # 总成交量

        delta = 2.0 * taker_buy - total_vol
        cvd += delta
```

#### 更新时机

**初始化时**：
```
步骤3: 批量初始化K线缓存
├─ 获取300根1h K线
├─ 获取200根4h K线
├─ 获取200根15m K线
└─ CVD从这些K线中计算 ✅
```

**Layer 1更新后**（每次扫描）：
```
📈 Layer 1更新价格 (0.2秒)
├─ 更新最后一根K线的收盘价
├─ 同时更新最后一根K线的最高价/最低价
└─ CVD从更新后的K线重新计算 ✅

计算方式：
- 使用最新的K线数据
- 计算最后一根K线的delta
- 累加到CVD序列
```

**Layer 2更新后**（智能触发）：
```
📊 Layer 2更新完整K线 (8-15秒)
├─ 获取最新2根完整K线
│   ├─ [9] takerBuyBaseVolume ← CVD计算需要
│   └─ [5] volume ← CVD计算需要
└─ CVD从新K线重新计算 ✅

计算方式：
- 完整K线包含准确的成交量数据
- 重新计算整个CVD序列
- 提供更准确的资金流分析
```

#### 数据新鲜度

| 时机 | CVD数据状态 | 准确度 |
|------|-----------|--------|
| **每次扫描** | ✅ 最新 | 高（基于最新价格） |
| **Layer 2触发** | ✅ 最新且更准确 | 很高（基于完整K线） |

#### 影响的因子

```
C因子（Capital Flow）：
- 直接使用CVD数据
- CVD上升 → 买方力量强 → C=+100
- CVD下降 → 卖方力量强 → C=-100
- CVD与价格背离 → 预警信号
```

---

### 2. 订单簿（Order Book）数据

#### 是什么？
```
订单簿 = 买卖盘深度数据（20档）

买盘：
  价格106000: 数量2.5 BTC
  价格105990: 数量1.8 BTC
  ...

卖盘：
  价格106010: 数量3.2 BTC
  价格106020: 数量2.1 BTC
  ...

用途：L因子（Liquidity 流动性）的核心数据
```

#### 更新时机

**⚠️ 重要：订单簿只在初始化时获取一次，后续不更新！**

```
初始化阶段（步骤5.3）：
├─ 批量获取200个币种的订单簿
├─ 每个币种获取20档深度
├─ 使用并发模式，20-30秒完成
└─ 存储在 self.orderbook_cache ✅

后续扫描：
├─ Layer 1: ❌ 不更新订单簿
├─ Layer 2: ❌ 不更新订单簿
├─ Layer 3: ❌ 不更新订单簿
└─ 直接使用缓存中的订单簿数据
```

#### 为什么不实时更新？

**原因分析**：

1. **API成本高**
   - 200个币种 × 每次扫描 = 200次API调用
   - 每5分钟扫描会很快达到限流

2. **流动性变化慢**
   - 主流币种（BTC/ETH）流动性稳定
   - 1小时内订单簿深度不会剧变

3. **性能影响大**
   - 实时获取需要20-30秒
   - 拖慢扫描速度

4. **L因子使用方式**
   - L因子主要看相对流动性
   - 币种之间的流动性排名不会快速改变
   - 使用初始化时的快照足够

#### 数据新鲜度

| 时机 | 订单簿数据 | 影响 |
|------|-----------|------|
| **初始化后** | 最新快照 | ✅ 准确 |
| **1小时后** | 1小时前的快照 | ⚠️ 可能略过时 |
| **重启后** | 重新获取 | ✅ 更新 |

#### 改进建议（未来优化）

```python
# 可以考虑在Layer 3中增加订单簿更新
if current_minute in [0, 30]:  # 每30分钟
    log("📊 [Layer 3] 更新订单簿深度...")
    await update_orderbook_cache(symbols)
```

#### 影响的因子

```
L因子（Liquidity 流动性）：
- 计算买卖盘深度
- 计算价差（spread）
- 流动性高 → L=+100 → 增加仓位
- 流动性低 → L=-100 → 减少仓位

影响：
- Gate 3 (Execution门) - 基于L因子
- position_multiplier - 仓位倍数调整
```

---

### 3. 资金费率（Funding Rate）数据

#### 更新时机

**Layer 3触发**（每30分钟）：
```
触发时间：00分、30分

更新内容：
├─ 当前资金费率
├─ 下次结算时间
└─ 存储在 market_data_cache['funding_rate']

币安结算时间：
- 00:00 UTC (北京时间 08:00)
- 08:00 UTC (北京时间 16:00)
- 16:00 UTC (北京时间 00:00)
```

**数据示例**：
```python
{
    'symbol': 'BTCUSDT',
    'funding_rate': 0.0001,        # 0.01%
    'funding_time': 1699056000000  # 下次结算
}
```

#### 数据新鲜度

| 时机 | 数据状态 | 说明 |
|------|---------|------|
| **刚更新** | 最新 | 准确反映当前费率 |
| **15分钟后** | 仍有效 | 资金费率每8小时才变化 |
| **7小时后** | 可能过时 | 接近下次结算 |

#### 影响的因子

```
F因子（Funding 资金费率）：
- 费率 > 0.05% → 多头过热 → F=-100
- 费率 < -0.05% → 空头过热 → F=+100
- |费率| < 0.01% → 平衡 → F=0
```

---

### 4. 持仓量（Open Interest）数据

#### 更新时机

**初始化阶段**（步骤5.5）：
```
批量获取300根1h持仓量历史数据
├─ 使用并发模式
├─ 耗时：10-20秒
└─ 存储在 self.oi_cache
```

**Layer 3触发**（每30分钟）：
```
触发时间：00分、30分

更新内容：
├─ 当前持仓量
├─ 与历史数据对比
└─ 存储在 market_data_cache['open_interest']
```

**数据示例**：
```python
{
    'symbol': 'BTCUSDT',
    'open_interest': 350000.5,  # 350,000 BTC
    'change_24h': +9.4%         # 24小时变化
}
```

#### 数据新鲜度

| 时机 | 数据状态 | 说明 |
|------|---------|------|
| **刚更新** | 最新 | 准确反映当前持仓 |
| **15分钟后** | 仍有效 | 持仓量变化较慢 |
| **29分钟后** | 可能略过时 | 接近下次更新 |

#### 影响的因子

```
O因子（Open Interest 持仓量）：
- OI增加 + 价格上涨 → 做多信心强 → O=+100
- OI增加 + 价格下跌 → 做空信心强 → O=-100
- OI减少 → 市场离场 → O趋向0
```

---

### 5. 现货价格（Spot Price）数据

#### 更新时机

**每次扫描时实时获取**（不缓存）：

```python
# 在初始化阶段步骤5.1
spot_prices = await client.get_ticker()  # 实时API调用

# 存储在 self.spot_price_cache
# 但每次扫描都会重新获取
```

#### 为什么每次都获取？

```
原因：
- 现货价格是B因子（Basis 基差）的关键数据
- 期现价差变化快
- API调用只需1次（批量获取所有币种）
- 耗时很短（<1秒）
```

#### 数据新鲜度

| 时机 | 数据状态 |
|------|---------|
| **每次扫描** | ✅ 实时最新 |

#### 影响的因子

```
B因子（Basis 基差）：
- 期货价格 vs 现货价格
- 期货溢价 > 5% → 多头过热 → B=-100
- 期货折价 > 5% → 空头过热 → B=+100
- 正常范围 → B=0
```

---

## 📋 6A+4B因子数据更新总表

### A层核心因子（6个）

| 因子 | 英文名 | 数据来源 | 更新频率 | 新鲜度 |
|------|-------|---------|---------|--------|
| **T** | Trend | K线价格 | Layer 1（每次） | ✅ 实时 |
| **M** | Momentum | K线价格 | Layer 1（每次） | ✅ 实时 |
| **C** | Capital | CVD（从K线） | Layer 1+2 | ✅ 实时 |
| **V** | Volatility | K线价格 | Layer 1（每次） | ✅ 实时 |
| **O** | OI | 持仓量历史 | Layer 3（30分钟） | 🔄 定时 |
| **B** | Basis | 现货价格 | 每次扫描 | ✅ 实时 |

### B层调制器（4个）

| 调制器 | 英文名 | 数据来源 | 更新频率 | 新鲜度 |
|-------|-------|---------|---------|--------|
| **L** | Liquidity | 订单簿 | **仅初始化** | ⚠️ 缓存 |
| **S** | Sentiment | K线+CVD | Layer 1+2 | ✅ 实时 |
| **F** | Funding | 资金费率 | Layer 3（30分钟） | 🔄 定时 |
| **I** | Index | BTC/ETH价格 | Layer 1（每次） | ✅ 实时 |

---

## 🕐 实际运行时间线示例

假设从 **23:00** 开始持续运行，每5分钟扫描一次：

```
23:00 - 初始化 (120秒)
  ├─ K线缓存初始化 (300根 × 4周期)
  ├─ CVD从K线计算 ✅
  ├─ 订单簿获取 ✅ (此后不再更新)
  ├─ 资金费率获取 ✅
  ├─ 持仓量历史获取 ✅
  └─ 现货价格获取 ✅

23:05 - 第1次扫描 (5.2秒)
  ├─ Layer 1: 更新价格 → CVD实时计算 ✅
  ├─ Layer 2: ✅ 触发！更新1h/4h K线 → CVD更准确 ✅
  ├─ Layer 3: ❌ 不触发
  ├─ 现货价格: ✅ 重新获取
  └─ 订单簿: ⏸️ 使用缓存（5分钟前）

23:10 - 第2次扫描 (0.7秒)
  ├─ Layer 1: 更新价格 → CVD实时计算 ✅
  ├─ Layer 2: ❌ 不触发
  ├─ Layer 3: ❌ 不触发
  ├─ 现货价格: ✅ 重新获取
  └─ 订单簿: ⏸️ 使用缓存（10分钟前）

23:17 - 第3次扫描 (5.7秒)
  ├─ Layer 1: 更新价格 → CVD实时计算 ✅
  ├─ Layer 2: ✅ 触发！更新15m K线 → CVD更准确 ✅
  ├─ Layer 3: ❌ 不触发
  ├─ 现货价格: ✅ 重新获取
  └─ 订单簿: ⏸️ 使用缓存（17分钟前）

23:30 - 第6次扫描 (6.9秒)
  ├─ Layer 1: 更新价格 → CVD实时计算 ✅
  ├─ Layer 2: ❌ 不触发
  ├─ Layer 3: ✅ 触发！更新资金费率+持仓量 ✅
  ├─ 现货价格: ✅ 重新获取
  └─ 订单簿: ⏸️ 使用缓存（30分钟前）

00:00 - 第12次扫描 (7.2秒)
  ├─ Layer 1: 更新价格 → CVD实时计算 ✅
  ├─ Layer 2: ❌ 不触发（等到05分）
  ├─ Layer 3: ✅ 触发！更新资金费率（可能刚结算） ✅
  ├─ 现货价格: ✅ 重新获取
  └─ 订单簿: ⏸️ 使用缓存（1小时前）⚠️

00:05 - 第13次扫描 (13.2秒)
  ├─ Layer 1: 更新价格 → CVD实时计算 ✅
  ├─ Layer 2: ✅ 触发！更新1h/4h K线 → CVD更准确 ✅
  ├─ Layer 3: ❌ 不触发
  ├─ 现货价格: ✅ 重新获取
  └─ 订单簿: ⏸️ 使用缓存（65分钟前）⚠️
```

---

## ⚠️ 数据新鲜度警告

### 订单簿数据（L因子）

**潜在问题**：
```
运行1小时后：
├─ 订单簿数据已1小时未更新
├─ 市场流动性可能已变化
└─ L因子可能不够准确
```

**影响程度**：
- ✅ **主流币**（BTC/ETH）：流动性稳定，影响小
- ⚠️ **小币种**：流动性波动大，可能影响较大
- ⚠️ **极端行情**：流动性枯竭时，数据会严重过时

**建议改进**：
```python
# 在Layer 3中增加订单簿更新
if current_minute in [0, 30]:  # 每30分钟
    # 更新资金费率+持仓量
    await update_market_data(symbols, client)

    # 🆕 新增：更新订单簿
    await update_orderbook_cache(symbols, client)
```

### CVD数据

**✅ 无问题**：
- Layer 1每次都更新K线价格
- CVD从最新K线实时计算
- Layer 2触发时获得更准确的完整K线
- 数据始终保持新鲜

---

## 💡 关键要点总结

### 每次扫描都更新的数据（实时）

✅ **K线价格**（Layer 1）
✅ **CVD数据**（从K线计算）
✅ **现货价格**（直接获取）
✅ **T/M/V因子**（基于最新价格）

### 智能触发更新的数据（准实时）

🔄 **完整K线**（Layer 2，8-15秒）
🔄 **CVD精确值**（Layer 2后重新计算）
🔄 **C因子精确值**（基于完整K线）

### 定时更新的数据（30分钟）

🔄 **资金费率**（Layer 3）
🔄 **持仓量**（Layer 3）
🔄 **F/O因子**（基于这两个数据）

### ⚠️ 仅初始化时获取的数据

⚠️ **订单簿**（初始化后不更新）
⚠️ **L因子**（基于订单簿缓存）

---

## 📊 数据更新流程图

```
初始化阶段（2分钟）
  ├─ K线缓存（300根 × 4周期）
  ├─ CVD计算（从K线）
  ├─ 订单簿（20档深度）← ⚠️ 此后不更新
  ├─ 资金费率
  ├─ 持仓量历史
  └─ 现货价格

每次扫描（0.2-15秒，取决于Layer触发）
  │
  ├─ Layer 1（必执行，0.2秒）
  │   ├─ 更新K线价格
  │   ├─ CVD实时计算
  │   ├─ 现货价格获取
  │   └─ 计算 T/M/C/V/B 因子
  │
  ├─ Layer 2（智能触发，8-15秒）
  │   ├─ 15m: 02/17/32/47分触发
  │   ├─ 1h/4h: 05/07分触发
  │   ├─ 更新完整K线
  │   ├─ CVD精确计算
  │   └─ C因子更准确
  │
  └─ Layer 3（定时触发，20-30秒）
      ├─ 00/30分触发
      ├─ 更新资金费率
      ├─ 更新持仓量
      └─ 计算 F/O 因子

分析阶段（<1秒/币种）
  ├─ 使用最新的6A因子
  ├─ 使用最新的4B调制器
  ├─ 计算Prime强度
  └─ 四门调节
```

---

**文档维护者**: Claude AI
**最后更新**: 2025-11-03
**适用版本**: CryptoSignal v6.6 Phase 1
