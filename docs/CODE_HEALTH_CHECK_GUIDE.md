# 代码级体检指南（Code Health Check Guide）

**版本**: v1.0
**创建日期**: 2025-11-15
**适用范围**: CryptoSignal 项目及类似系统级代码库
**方法论来源**: v7.3.2-Full I 因子体检实践总结

---

## 📋 目录

1. [什么是代码级体检](#什么是代码级体检)
2. [核心方法论](#核心方法论)
3. [标准检查流程](#标准检查流程)
4. [问题分级标准](#问题分级标准)
5. [报告模板](#报告模板)
6. [工具和技巧](#工具和技巧)
7. [最佳实践](#最佳实践)

---

## 什么是代码级体检

### 定义

**代码级体检**（Code Health Check）是一种系统化的代码审查方法，通过**对照设计文档/需求规范**检查**真实代码实现**，发现：
- 逻辑硬伤（会导致程序崩溃或计算错误）
- 架构偏差（实现与设计不一致）
- 工程规范违背（硬编码、缺少配置等）
- 潜在风险（边界条件、降级处理缺失等）

### 与普通 Code Review 的区别

| 对比维度 | 普通 Code Review | 代码级体检 |
|---------|-----------------|-----------|
| **时机** | PR 提交时（增量） | 任意时间（全量） |
| **范围** | 单次提交的变更 | 整个子系统/模块 |
| **目标** | 发现代码质量问题 | 发现实现与设计的偏差 |
| **方法** | 逐行审查代码 | 系统化检查清单 + 对照设计文档 |
| **输出** | 评论和建议 | 分级问题清单 + 修复路线图 |

### 何时需要代码级体检

✅ **推荐场景**：
1. **大版本重构后**：验证重构是否按设计落地（如 v7.3.2-Full I 因子重构）
2. **接手遗留系统**：快速了解系统健康状况
3. **上线前审查**：发现潜在的 P0/P1 级硬伤
4. **性能/稳定性问题排查**：系统性检查可能的根因
5. **定期健康检查**：季度/半年度的代码库体检

❌ **不适用场景**：
- 单个小功能开发（用普通 Code Review）
- 原型验证阶段（允许快速迭代）
- 紧急 hotfix（先修复，后体检）

---

## 核心方法论

### 体检三原则

#### 1. **对照驱动**（Reference-Driven）
- ❌ 不要凭空猜测代码应该怎么写
- ✅ 对照设计文档、需求规范、架构图检查实现

**示例**：
```
设计文档说：I 因子使用 BTC-only 回归 + 时间戳对齐
              ↓
检查代码：   calculate_beta_btc_only() 是否有 timestamps 参数？
              ↓
发现问题：   ❌ 仅按索引对齐，无时间戳参数 → P0 硬伤
```

#### 2. **分层检查**（Layered Inspection）
不要试图一次性检查所有细节，按层次逐步深入：

```
Layer 1: 架构层（接口、数据流）
  ↓
Layer 2: 逻辑层（算法实现、边界条件）
  ↓
Layer 3: 工程层（配置管理、错误处理、日志）
  ↓
Layer 4: 优化层（性能、可维护性）
```

#### 3. **证据链**（Evidence Chain）
每个问题都要有完整的证据链：

```
问题描述 + 文件路径 + 行号 + 代码片段 + 预期行为 + 实际行为 + 影响分析
```

**反例**（无证据）：
> "I 因子实现有问题"  ❌

**正例**（完整证据链）：
> **P0-1: 时间戳对齐缺失**
> **文件**: `ats_core/factors_v2/independence.py`
> **位置**: Line 176-177
> **问题**: 当前仅按索引对齐 `alt_prices[-window:]`，无时间戳参数
> **预期**: 应该使用 `np.intersect1d(alt_ts, btc_ts)` 对齐
> **影响**: β 值计算可能错位，I 因子失效
> **优先级**: P0 Critical  ✅

---

## 标准检查流程

### 📌 四步检查法（Step-by-Step Checklist）

#### **Step 1: 核心实现检查**
检查目标：核心算法/逻辑是否按设计实现

**检查清单**：
- [ ] **函数签名**：参数列表是否与设计文档一致？
- [ ] **算法实现**：核心公式/逻辑是否正确？
- [ ] **数据流**：输入 → 处理 → 输出 是否完整？
- [ ] **边界条件**：空输入、极端值、异常情况是否处理？
- [ ] **返回值**：类型、数量、含义是否与文档一致？

**示例（I 因子）**：
```markdown
## Step 1 检查清单

### 1.1 BTC-only 回归
- [x] 函数参数是否只有 ALT + BTC（无 ETH）？
- [x] 回归公式是否是 `alt_ret = α + β_BTC * btc_ret`？
- [ ] ⚠️ 是否有时间戳对齐？（缺失 → P0）

### 1.2 log-return 计算
- [x] 是否使用 `np.log(prices[t] / prices[t-1])`？
- [x] 是否有 epsilon 保护防止 log(0)？

### 1.3 R² 过滤
- [x] 是否有 R² < r2_min 的过滤逻辑？
- [ ] ⚠️ r2_min 是否从配置读取？（硬编码 → P1）
```

---

#### **Step 2: 调用链检查**
检查目标：上下游是否正确对接

**检查清单**：
- [ ] **调用参数**：调用端传入的参数是否与核心实现匹配？
- [ ] **返回值解构**：调用端解构的返回值数量是否正确？
- [ ] **数据类型**：是否有类型转换错误（如 List vs np.ndarray）？
- [ ] **错误传播**：异常/错误状态是否正确传播？
- [ ] **依赖关系**：是否有循环依赖或缺失依赖？

**检查方法**：
1. 从核心函数定义出发：`def calculate_beta_btc_only(...)`
2. 全局搜索调用点：`Grep "calculate_beta_btc_only"`
3. 逐个检查调用参数和返回值解构是否匹配

**常见问题**：
```python
# ❌ 常见错误 1: 返回值数量不匹配
# independence.py
def score_independence(...) -> Tuple[int, Dict]:  # 2 个返回值
    return I_score, metadata

# analyze_symbol.py（错误）
I, beta_sum, meta = score_independence(...)  # ❌ 解构 3 个值 → ValueError

# ✅ 正确
I, meta = score_independence(...)  # ✅ 2 个值
```

---

#### **Step 3: 配置管理检查**
检查目标：是否做到零硬编码（配置驱动）

**检查清单**：
- [ ] **配置文件存在性**：所需的 JSON/YAML 配置文件是否存在？
- [ ] **配置加载器**：是否有统一的配置加载类（如 RuntimeConfig）？
- [ ] **配置使用**：代码是否从配置读取参数（而非硬编码）？
- [ ] **降级处理**：配置加载失败时是否有合理的默认值？
- [ ] **配置校验**：是否有配置格式校验（防止误配置）？

**魔法数字扫描方法**：

1. **识别业务常量**（可能需要配置的数字）：
   ```python
   # 业务常量（应该配置化）
   window_hours = 24      # ← 回归窗口
   min_points = 16        # ← 最小样本数
   r2_min = 0.1           # ← R² 阈值
   beta_boundaries = [0.6, 0.9, 1.2, 1.5]  # ← Beta 分档
   ```

2. **识别数学常量**（可以硬编码）：
   ```python
   # 数学/物理常量（允许硬编码）
   np.pi                  # ← 数学常数
   speed_of_light = 299792458  # ← 物理常数
   ```

3. **识别 epsilon**（应该配置化）：
   ```python
   # Epsilon 系列（应该从 numeric_stability.json 读取）
   eps_var_min = 1e-12    # ← 应该配置
   eps_log_price = 1e-10  # ← 应该配置
   ```

**扫描技巧**：
```bash
# 搜索独立数字（排除注释和字符串）
grep -n "[^a-zA-Z_]0\.[0-9]\+[^0-9]" independence.py
grep -n "[^a-zA-Z_][1-9][0-9]*[^0-9a-zA-Z_]" independence.py
```

**记录模板**：
| 位置 | 数字 | 用途 | 状态 |
|------|------|------|------|
| Line 286 | `24` | window_hours 默认值 | ⚠️ 硬编码 |
| Line 292 | `0.1` | r2_min 默认值 | ⚠️ 硬编码 |
| Line 165 | `1e-10` | 降级 epsilon | ✅ 仅降级用 |

---

#### **Step 4: 错误处理和边界条件检查**
检查目标：系统稳定性和健壮性

**检查清单**：
- [ ] **空输入**：输入为空/None 时是否正确处理？
- [ ] **极端值**：输入为 0/Inf/NaN 时是否有保护？
- [ ] **数据不足**：样本数不够时是否降级处理？
- [ ] **异常捕获**：是否有合理的 try-except（不过度捕获）？
- [ ] **错误日志**：异常时是否记录足够的调试信息？
- [ ] **降级策略**：关键依赖失败时是否有备用方案？

**反模式识别**：
```python
# ❌ 反模式 1: 过度捕获（隐藏真实错误）
try:
    result = complex_calculation()
except Exception:
    result = 0  # ← 太宽泛，隐藏了真实问题

# ✅ 改进
try:
    result = complex_calculation()
except (ValueError, ZeroDivisionError) as e:
    logger.warning(f"计算失败: {e}，使用默认值")
    result = 0
```

```python
# ❌ 反模式 2: 无边界检查
beta_btc = calculate_beta(alt, btc)
I_score = 85 + (0.6 - beta_btc) * 25  # ← beta_btc 可能 > 0.6 导致 I > 100

# ✅ 改进
I_raw = 85 + (0.6 - beta_btc) * 25
I_score = int(np.clip(I_raw, 0, 100))  # ← 截断到 [0, 100]
```

---

## 问题分级标准

### 优先级定义（P0-P3）

| 级别 | 名称 | 定义 | 影响范围 | 修复时间窗口 | 示例 |
|------|------|------|---------|-------------|------|
| **P0** | Critical | **会导致程序崩溃或计算结果完全错误** | 核心功能失效 | 立即修复（当前 sprint） | 时间戳对齐缺失 → β 计算错位 |
| **P1** | High | **核心功能受损或工程规范严重违背** | 部分功能失效或风险积累 | 本周内修复 | veto 逻辑失效、零硬编码未完成 |
| **P2** | Medium | **非核心功能问题或可维护性问题** | 边缘场景或开发效率 | 下个迭代 | 日志不完善、注释缺失 |
| **P3** | Low | **优化建议或技术债** | 性能、可读性 | 有空再说 | 变量命名、代码重复 |

### 问题类型分类

#### 1. **逻辑硬伤**（Logic Defects）
会导致计算错误或功能失效的问题

**识别标准**：
- 算法实现与数学公式不符
- 数据对齐错误（时间戳、索引）
- 边界条件处理缺失
- 返回值类型/数量不匹配

**优先级**：通常 P0-P1

#### 2. **架构偏差**（Architecture Deviation）
实现与设计文档不一致

**识别标准**：
- 设计说 BTC-only，代码还在用 ETH
- 设计说用 log-return，代码用 simple return
- 接口签名与设计不一致

**优先级**：P1-P2（取决于偏差程度）

#### 3. **工程规范违背**（Engineering Standard Violation）
违反项目工程规范（如零硬编码）

**识别标准**：
- 业务常量硬编码在代码里
- 缺少配置文件或配置未使用
- 缺少日志、错误处理
- 缺少单元测试

**优先级**：P1-P2

#### 4. **潜在风险**（Potential Risks）
当前可能没问题，但未来可能引发故障

**识别标准**：
- 缺少降级处理
- 假设输入总是有效（无边界检查）
- 过度依赖外部服务（无超时）
- 性能瓶颈（如 O(n²) 算法）

**优先级**：P2-P3

---

## 报告模板

### 完整报告结构

```markdown
# [子系统名称] 代码级体检报告

**体检日期**: YYYY-MM-DD
**体检范围**: [具体模块/功能]
**体检工程师**: [姓名]
**版本**: [代码版本号]

---

## 一、当前状态评估（基于真实代码）

### 1.1 [核心模块 A] 结构分析

#### ✅ **[检查项 1]**：已满足
- **检查内容**: ...
- **证据**: 文件路径 + 行号 + 代码片段
- **结论**: ...

#### ❌ **[检查项 2]**：未实现（P0 级硬伤）
- **检查内容**: ...
- **问题**: ...
- **影响**: ...
- **优先级**: P0 Critical

### 1.2 [核心模块 B] 调用链分析
...

---

## 二、是否存在"会导致程序直接崩"的硬伤

### 🚨 **P0 Critical 级硬伤**：X 个

#### **P0-1: [问题标题]**
**文件**: `path/to/file.py`
**位置**: Line XXX-YYY
**问题**: [详细描述]
**错误类型**: [逻辑错误/接口不匹配/...]
**影响范围**: [哪些功能受影响]
**修复优先级**: P0 (Immediate)

**预期实现**（代码示例）：
```python
# 正确的实现应该是...
```

---

## 三、是否满足"零硬编码"目标

### 📊 **零硬编码达成度**：X% (部分满足/完全满足)

#### ✅ **已实现零硬编码的部分**（X/Y）：
1. [配置项 1] ✅
   - 配置文件：`config/xxx.json`
   - 使用位置：`module.py` Line XXX
   - 涉及参数：...

#### ❌ **仍然硬编码的部分**（Y/Y）：
1. [配置项 1] ❌
   - 硬编码位置：`module.py` Line XXX
   - 涉及参数：...
   - 应该从哪里读取：...

---

## 四、修复路线图

### 🚨 **P0 级（必须立即修）**：X 项

#### **P0-1: [问题标题]**

**影响**: [简述影响]
**修复难度**: 🔴 High / 🟡 Medium / 🟢 Low
**预计工时**: X 小时

**修复步骤**：
1. [步骤 1]
2. [步骤 2]
3. ...

**验证方式**：
```python
# 测试用例
```

---

### ⚠️ **P1 级（本周内修）**：X 项
...

---

## 五、总结 & 建议

### ✅ **做得好的地方**：
1. ...
2. ...

### ❌ **需要改进的地方**：
1. ...
2. ...

### 🎯 **行动建议**：
1. **立即执行 P0-X**（问题描述）- 理由
2. **本周内完成 P1-X**（问题描述）- 理由
3. **下周迭代完成 P2-X**（问题描述）- 理由

---

**体检完毕！** 🏁
```

---

## 工具和技巧

### 代码搜索技巧

#### 1. **全局函数调用搜索**
```bash
# 查找函数定义
grep -n "^def calculate_beta" ats_core/factors_v2/*.py

# 查找函数调用（排除注释和定义）
grep -n "calculate_beta(" ats_core/**/*.py | grep -v "def calculate_beta"

# 查找导入
grep -n "from.*import.*calculate_beta" ats_core/**/*.py
```

#### 2. **魔法数字扫描**
```bash
# 查找浮点数（如 0.6, 1.2）
grep -n "\b0\.[0-9]\+\b" independence.py

# 查找整数（排除常见的 0, 1, 2）
grep -n "\b[3-9][0-9]*\b" independence.py

# 查找科学记数法（如 1e-10）
grep -n "[0-9]e-[0-9]" independence.py
```

#### 3. **接口匹配检查**
```bash
# 查找函数签名
grep -A5 "^def score_independence" independence.py

# 查找返回语句
grep -n "return.*," independence.py | grep score_independence
```

### 使用 IDE/编辑器功能

#### VS Code
- **全局搜索**: `Ctrl+Shift+F`
- **跳转定义**: `F12`
- **查找引用**: `Shift+F12`
- **符号搜索**: `Ctrl+T` → 输入函数名

#### Claude Code (当前环境)
- **文件读取**: `Read` tool
- **内容搜索**: `Grep` tool（支持正则）
- **文件查找**: `Glob` tool（支持通配符）

### 自动化脚本示例

#### 魔法数字扫描脚本
```python
#!/usr/bin/env python3
"""
魔法数字扫描器 - 自动识别代码中的硬编码常量
"""
import re
import sys

def scan_magic_numbers(file_path):
    """扫描文件中的魔法数字"""
    with open(file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    # 正则：匹配独立的数字（不在变量名中）
    float_pattern = r'\b\d+\.\d+\b'
    int_pattern = r'\b(?!0|1|2\b)\d+\b'  # 排除常见的 0, 1, 2
    sci_pattern = r'\d+e-?\d+'

    results = []
    for i, line in enumerate(lines, start=1):
        # 跳过注释和字符串
        if line.strip().startswith('#'):
            continue

        # 查找浮点数
        for match in re.finditer(float_pattern, line):
            results.append({
                'line': i,
                'value': match.group(),
                'type': 'float',
                'context': line.strip()
            })

        # 查找整数
        for match in re.finditer(int_pattern, line):
            results.append({
                'line': i,
                'value': match.group(),
                'type': 'int',
                'context': line.strip()
            })

        # 查找科学记数法
        for match in re.finditer(sci_pattern, line):
            results.append({
                'line': i,
                'value': match.group(),
                'type': 'scientific',
                'context': line.strip()
            })

    return results

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("用法: python scan_magic_numbers.py <file_path>")
        sys.exit(1)

    file_path = sys.argv[1]
    results = scan_magic_numbers(file_path)

    print(f"📊 魔法数字扫描结果：{file_path}")
    print(f"发现 {len(results)} 个候选常量\n")

    for r in results:
        print(f"Line {r['line']:4d} | {r['type']:10s} | {r['value']:10s} | {r['context'][:60]}")
```

---

## 最佳实践

### ✅ DO（推荐做法）

1. **对照文档检查**
   - ✅ 检查前先阅读设计文档、需求规范
   - ✅ 将设计中的关键点列成清单，逐项核对

2. **保留完整证据链**
   - ✅ 每个问题都记录：文件 + 行号 + 代码片段 + 影响分析
   - ✅ 截图或复制关键代码到报告中

3. **分级优先级**
   - ✅ 使用 P0-P3 分级，明确修复时间窗口
   - ✅ P0 必须立即修，P1 本周内，P2 下迭代

4. **提供修复方案**
   - ✅ 不仅指出问题，还给出具体修复代码
   - ✅ 复杂问题提供分步修复指南

5. **量化结果**
   - ✅ 使用百分比（如"零硬编码达成度 60%"）
   - ✅ 使用表格对比（修复前 vs 修复后）

### ❌ DON'T（避免做法）

1. **凭空假设**
   - ❌ "我觉得这里应该这样写" → 没有依据
   - ✅ "设计文档第 X 页说应该 Y，但代码实现是 Z"

2. **过度细节**
   - ❌ 检查每一行代码的变量命名
   - ✅ 聚焦核心逻辑、接口、配置管理

3. **主观评价**
   - ❌ "这段代码写得很烂"
   - ✅ "这段代码硬编码了 10 个常量，违反零硬编码规范（P1）"

4. **无优先级**
   - ❌ 列出 50 个问题但不分优先级
   - ✅ 分级：3 个 P0 + 5 个 P1 + 15 个 P2

5. **只发现问题不给方案**
   - ❌ "时间戳对齐缺失" → 然后呢？
   - ✅ "时间戳对齐缺失 → 需要添加 timestamps 参数，修改 5 个文件，预计 2 小时"

---

## 附录：检查清单速查表

### 快速检查清单（10 分钟版）

适用场景：快速健康检查、PR 前自查

- [ ] **核心算法**：公式/逻辑与文档一致？
- [ ] **接口匹配**：函数签名、返回值无变更？
- [ ] **边界条件**：空输入、极端值有处理？
- [ ] **配置管理**：无新增硬编码？
- [ ] **错误处理**：异常有捕获和日志？

### 完整检查清单（2 小时版）

适用场景：子系统重构后、上线前审查

- [ ] **Step 1: 核心实现检查**（30 分钟）
  - [ ] 算法实现正确性
  - [ ] 数据流完整性
  - [ ] 边界条件处理
  - [ ] 返回值匹配

- [ ] **Step 2: 调用链检查**（30 分钟）
  - [ ] 调用参数匹配
  - [ ] 返回值解构正确
  - [ ] 类型转换无误
  - [ ] 错误传播正确

- [ ] **Step 3: 配置管理检查**（30 分钟）
  - [ ] 配置文件存在
  - [ ] 配置加载器可用
  - [ ] 魔法数字已配置化
  - [ ] 降级处理完善

- [ ] **Step 4: 错误处理检查**（30 分钟）
  - [ ] 异常捕获合理
  - [ ] 日志记录充分
  - [ ] 降级策略存在
  - [ ] 边界检查完整

---

## 修订历史

| 版本 | 日期 | 修改内容 | 作者 |
|------|------|---------|------|
| v1.0 | 2025-11-15 | 初始版本，基于 v7.3.2-Full I 因子体检实践总结 | Claude Code |

---

## 参考资料

- [FACTOR_SYSTEM_COMPLETE_DESIGN.md](./FACTOR_SYSTEM_COMPLETE_DESIGN.md) - I 因子设计文档
- [SYSTEM_ENHANCEMENT_STANDARD.md](./SYSTEM_ENHANCEMENT_STANDARD.md) - 系统增强规范
- [CODE_HEALTH_CHECK_TEMPLATE.md](./CODE_HEALTH_CHECK_TEMPLATE.md) - 体检报告模板

---

**祝体检顺利！🩺**
