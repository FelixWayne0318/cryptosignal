# ğŸ—ï¸ ç»Ÿä¸€ç³»ç»Ÿæ¶æ„è®¾è®¡æ–¹æ¡ˆ

**CryptoSignalå®Œæ•´æ•´åˆæ–¹æ¡ˆï¼š12ä¸ªå¾®è§‚ç»“æ„å› å­ + ç°æœ‰7ç»´å› å­**

**è®¾è®¡åŸåˆ™**ï¼š
1. âŒ **ä¸å †ç Œ** - ä¸æ˜¯ç®€å•æ·»åŠ 12ä¸ªå› å­
2. âœ… **æœ‰æœºæ•´åˆ** - èåˆ/æ›¿æ¢/å¢å¼ºç°æœ‰ç»´åº¦
3. âœ… **å‚æ•°ç»Ÿç­¹** - ç»Ÿä¸€é…ç½®ç®¡ç†
4. âœ… **é˜²è¿‡æ‹Ÿåˆ** - å› å­æ­£äº¤åŒ– + æ ·æœ¬å¤–éªŒè¯
5. âœ… **å…¨æµç¨‹ä¼˜åŒ–** - é€‰å¸â†’åˆ†æâ†’é£é™©â†’å‘å¸ƒ

ç”Ÿæˆæ—¶é—´: 2025-10-27
è®¾è®¡è€…: Claude (ä¸–ç•Œé¡¶çº§é‡åŒ–æ¶æ„å¸ˆè§†è§’)

---

## ğŸ“Š ç°çŠ¶åˆ†æ

### ç°æœ‰å› å­ä½“ç³»ï¼ˆ7+1ç»´ï¼‰

| ç»´åº¦ | åç§° | æ•°æ®æº | æƒé‡ | è¯„ä»· |
|------|------|--------|------|------|
| **T** | Trend | 1h/4h Kçº¿ | 30 | â­â­â­â­ æ ¸å¿ƒ |
| **M** | Momentum | 1h Kçº¿ | 15 | â­â­â­ ä¸­ç­‰ |
| **C** | CVD Flow | 1h Kçº¿(taker) | 20 | â­â­â­â­ æ ¸å¿ƒ |
| **S** | Structure | 4h Kçº¿ | 10 | â­â­â­ ä¸­ç­‰ |
| **V** | Volume | 1h Kçº¿ | 15 | â­â­â­ ä¸­ç­‰ |
| **O** | OI | 1h OI | 15 | â­â­â­ ä¸­ç­‰ï¼ˆå¯å¢å¼ºï¼‰|
| **E** | Environment | 1h/4h Kçº¿ | 10 | â­â­ è¾ƒå¼± |
| **F** | Fund Leading | CVD | è°ƒèŠ‚å™¨ | â­â­â­â­ æ ¸å¿ƒ |

**æ€»æƒé‡**: 115ï¼ˆå®é™…100 + Fè°ƒèŠ‚ï¼‰

**ç°æœ‰é—®é¢˜**:
1. âš ï¸ **ç¼ºå°‘æµåŠ¨æ€§ç»´åº¦** - æœªè€ƒè™‘è®¢å•ç°¿æ·±åº¦ã€æ»‘ç‚¹
2. âš ï¸ **ç¼ºå°‘å¸‚åœºæƒ…ç»ª** - æœªè€ƒè™‘åŸºå·®ã€èµ„é‡‘è´¹
3. âš ï¸ **ç¼ºå°‘æ¸…ç®—é£é™©** - æœªè€ƒè™‘æ¸…ç®—å¯†åº¦
4. âš ï¸ **OIåˆ†æè¿‡ç®€** - æœªåŒºåˆ†åŠ ä»“ vs å¹³ä»“
5. âš ï¸ **Eç»´åº¦è¾ƒå¼±** - æ³¢åŠ¨ç‡+ç©ºé—´çš„ç»„åˆæ„ä¹‰ä¸å¤§

### 12ä¸ªå¾®è§‚ç»“æ„å› å­æ˜ å°„

| # | å› å­ | å¯¹åº”ç°æœ‰ç»´åº¦ | å¤„ç†æ–¹å¼ |
|---|------|-------------|---------|
| 1 | åˆæˆCVD | **C** | ğŸ”„ **å¢å¼º** |
| 2 | è®¢å•ç°¿æ‰¿è½½åŠ› | - | â• **æ–°å¢L** |
| 3 | LDIç°¿æŠ½æ°´ | **L** | ğŸ”— **åˆå¹¶åˆ°L** |
| 4 | OIå››è±¡é™ | **O** | ğŸ”„ **å¢å¼º** |
| 5 | åŸºå·®èµ„é‡‘è´¹ | - | â• **æ–°å¢B** |
| 6 | FWIä¸´çª— | **B** | ğŸ”— **åˆå¹¶åˆ°B** |
| 7 | æ¸…ç®—å¯†åº¦ | - | â• **æ–°å¢Q** |
| 8 | è·¨æ‰€CVP | **C** | ğŸ”— **å¯é€‰å¢å¼ºC** |
| 9 | é¢†æ¶¨å›ä¼ Î² | **E** | ğŸ”„ **æ›¿æ¢Eâ†’I** |
| 10 | æœŸæƒGamma | - | âŒ **èˆå¼ƒ** |
| 11 | ç¨³å®šå¸å‡€æµ | **M** | ğŸ”— **å¯é€‰å¢å¼ºM** |
| 12 | è§¦å‘K | **V** | ğŸ”„ **å¢å¼º** |

**æ•´åˆç­–ç•¥**:
- **ä¿ç•™**: T, M, C, S, V, O, Fï¼ˆ7ä¸ªï¼‰
- **å¢å¼º**: Câ†’C+, Oâ†’O+, Vâ†’V+ï¼ˆ3ä¸ªï¼‰
- **æ›¿æ¢**: Eâ†’Iï¼ˆ1ä¸ªï¼‰
- **æ–°å¢**: L, B, Qï¼ˆ3ä¸ªæ ¸å¿ƒï¼‰
- **èˆå¼ƒ**: #10æœŸæƒGammaï¼ˆ1ä¸ªï¼‰
- **å¯é€‰**: #3,#6,#8,#11ï¼ˆåæœŸæ•´åˆï¼‰

**æœ€ç»ˆç»´åº¦**: **10ç»´** (T, M, C+, S, V+, O+, I, L, B, Q) + **Fè°ƒèŠ‚å™¨**

---

## ğŸ¯ ç»Ÿä¸€å› å­æ¶æ„

### æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç»Ÿä¸€å› å­å¼•æ“ï¼ˆ10+1ç»´ï¼‰                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Layer 1: ä»·æ ¼è¡Œä¸ºå±‚ï¼ˆPrice Actionï¼‰                â”‚    â”‚
â”‚  â”‚  - T: Trendï¼ˆè¶‹åŠ¿ï¼‰          æƒé‡=25 â­â­â­â­â­    â”‚    â”‚
â”‚  â”‚  - M: Momentumï¼ˆåŠ¨é‡ï¼‰       æƒé‡=15 â­â­â­â­      â”‚    â”‚
â”‚  â”‚  - S: Structureï¼ˆç»“æ„ï¼‰      æƒé‡=10 â­â­â­        â”‚    â”‚
â”‚  â”‚  - V+: Volume+Triggerï¼ˆé‡èƒ½+è§¦å‘Kï¼‰ æƒé‡=15 â­â­â­â­â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚           å°è®¡: 65åˆ†                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Layer 2: èµ„é‡‘æµå±‚ï¼ˆMoney Flowï¼‰                    â”‚    â”‚
â”‚  â”‚  - C+: Enhanced CVDï¼ˆå¢å¼ºCVDï¼‰æƒé‡=20 â­â­â­â­â­   â”‚    â”‚
â”‚  â”‚  - O+: OI Regimeï¼ˆOIå››è±¡é™ï¼‰  æƒé‡=20 â­â­â­â­â­   â”‚    â”‚
â”‚  â”‚  - F: Fund Leadingï¼ˆè°ƒèŠ‚å™¨ï¼‰  è°ƒèŠ‚å™¨ â­â­â­â­â­     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚           å°è®¡: 40åˆ† + Fè°ƒèŠ‚                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Layer 3: å¾®è§‚ç»“æ„å±‚ï¼ˆMicrostructureï¼‰              â”‚    â”‚
â”‚  â”‚  - L: Liquidityï¼ˆæµåŠ¨æ€§ï¼‰     æƒé‡=20 â­â­â­â­â­    â”‚    â”‚
â”‚  â”‚  - B: Basis+Fundingï¼ˆåŸºå·®+èµ„é‡‘è´¹ï¼‰æƒé‡=15 â­â­â­â­  â”‚    â”‚
â”‚  â”‚  - Q: Liquidationï¼ˆæ¸…ç®—å¯†åº¦ï¼‰  æƒé‡=10 â­â­â­â­     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚           å°è®¡: 45åˆ†                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Layer 4: å¸‚åœºç¯å¢ƒå±‚ï¼ˆMarket Contextï¼‰              â”‚    â”‚
â”‚  â”‚  - I: Independenceï¼ˆç‹¬ç«‹æ€§Î²ï¼‰  æƒé‡=10 â­â­â­â­     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚           å°è®¡: 10åˆ†                                         â”‚
â”‚                                                               â”‚
â”‚  æ€»æƒé‡: 160åˆ† â†’ å½’ä¸€åŒ–åˆ° Â±100                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å› å­è¯¦ç»†è®¾è®¡

#### **Layer 1: ä»·æ ¼è¡Œä¸ºå±‚ï¼ˆ65åˆ†ï¼‰**

##### 1. T - Trendï¼ˆä¿ç•™ï¼Œæƒé‡25ï¼‰
```python
# ç°æœ‰å®ç°ä¿æŒä¸å˜
def calculate_trend(klines_1h, klines_4h):
    """
    EMAäº¤å‰ + æ–œç‡/ATR
    Range: -100 åˆ° +100
    """
    # ç°æœ‰é€»è¾‘...
    return score  # -100 ~ +100
```

**å‚æ•°**ï¼ˆç°æœ‰ï¼‰:
- `ema_short`: 10
- `ema_long`: 50
- `atr_period`: 14

##### 2. M - Momentumï¼ˆä¿ç•™ï¼Œæƒé‡15ï¼‰
```python
# ç°æœ‰å®ç°ä¿æŒä¸å˜
def calculate_momentum(klines_1h):
    """
    ä»·æ ¼åŠ é€Ÿåº¦
    Range: -100 åˆ° +100
    """
    # ç°æœ‰é€»è¾‘...
    return score
```

**å¯é€‰å¢å¼º**ï¼ˆ#11ç¨³å®šå¸å‡€æµï¼‰:
```python
# åæœŸå¯æ•´åˆç¨³å®šå¸ä¾›åº”é‡å˜åŒ–
def calculate_momentum_enhanced(klines_1h, stable_supply_growth=None):
    base_score = calculate_momentum(klines_1h)

    if stable_supply_growth is not None:
        # ç¨³å®šå¸ä¾›åº”å¢é•¿ â†’ å¢å¼ºçœ‹æ¶¨åŠ¨é‡
        stable_boost = min(20, stable_supply_growth / 0.001 * 20)
        base_score += stable_boost if base_score > 0 else 0

    return max(-100, min(100, base_score))
```

##### 3. S - Structureï¼ˆä¿ç•™ï¼Œæƒé‡10ï¼‰
```python
# ç°æœ‰å®ç°ä¿æŒä¸å˜
def calculate_structure(klines_4h):
    """
    æ”¯æ’‘é˜»åŠ›è´¨é‡
    Range: -100 åˆ° +100
    """
    # ç°æœ‰é€»è¾‘...
    return score
```

##### 4. V+ - Volume+Triggerï¼ˆå¢å¼ºï¼Œæƒé‡15ï¼‰
```python
# æ•´åˆ #12 è§¦å‘K
def calculate_volume_enhanced(klines, support_levels, resistance_levels):
    """
    æˆäº¤é‡æ”¾å¤§ + è§¦å‘Kæ£€æµ‹

    æ•´åˆ:
    - åŸæœ‰: ç›¸å¯¹æˆäº¤é‡ z-score
    - æ–°å¢: å®ä½“æ¯”ä¾‹ + çªç ´æ£€æµ‹

    Range: -100 åˆ° +100
    """
    # === 1. åŸæœ‰æˆäº¤é‡è¯„åˆ†ï¼ˆ60%æƒé‡ï¼‰===
    vol_score = calculate_volume_original(klines)  # ç°æœ‰é€»è¾‘

    # === 2. è§¦å‘Kå¢å¼ºï¼ˆ40%æƒé‡ï¼‰===
    last_k = klines[-1]
    O, H, L, C = last_k[1], last_k[2], last_k[3], last_k[4]
    Vol = last_k[5]

    # 2.1 å®ä½“æ¯”ä¾‹
    body_ratio = abs(C - O) / (H - L) if (H - L) > 0 else 0
    body_score = 100 if body_ratio >= 0.6 else (body_ratio / 0.6 * 100)

    # 2.2 çªç ´æ£€æµ‹
    atr = calculate_atr(klines)
    breakthrough = 0

    for resistance in resistance_levels:
        if C > resistance and (C - resistance) >= 0.25 * atr:
            breakthrough = 100
            break

    for support in support_levels:
        if C < support and (support - C) >= 0.25 * atr:
            breakthrough = -100
            break

    # 2.3 è§¦å‘Kç»¼åˆè¯„åˆ†
    trigger_score = (body_score * 0.5 + abs(breakthrough) * 0.5) * np.sign(C - O)

    # === 3. èåˆè¯„åˆ† ===
    final_score = vol_score * 0.6 + trigger_score * 0.4

    return max(-100, min(100, final_score))
```

**æ–°å¢å‚æ•°**:
- `trigger_body_ratio_min`: 0.6
- `trigger_breakthrough_atr_mult`: 0.25

#### **Layer 2: èµ„é‡‘æµå±‚ï¼ˆ40åˆ† + Fè°ƒèŠ‚ï¼‰**

##### 5. C+ - Enhanced CVDï¼ˆå¢å¼ºï¼Œæƒé‡20ï¼‰
```python
# æ•´åˆ #1 åˆæˆCVD + #8 è·¨æ‰€CVPï¼ˆå¯é€‰ï¼‰
def calculate_cvd_enhanced(symbol, klines_perp_1h, klines_spot_1h,
                           use_cross_exchange=False):
    """
    å¢å¼ºCVD:
    - åŸæœ‰: ç°è´§+æœŸè´§æ··åˆCVD
    - æ–°å¢: åŠ¨æ€æƒé‡ + EMAå¹³æ»‘
    - å¯é€‰: è·¨äº¤æ˜“æ‰€éªŒè¯

    Range: -100 åˆ° +100
    """
    # === 1. åŠ¨æ€æƒé‡è®¡ç®— ===
    perp_vol_1h = sum([k[7] for k in klines_perp_1h[-60:]])
    spot_vol_1h = sum([k[7] for k in klines_spot_1h[-60:]])

    w_perp = perp_vol_1h / (perp_vol_1h + spot_vol_1h + 1e-9)
    w_spot = 1 - w_perp

    # === 2. CVDè®¡ç®— ===
    cvd_perp = cvd_from_klines(klines_perp_1h, use_taker_buy=True)
    cvd_spot = cvd_from_klines(klines_spot_1h, use_taker_buy=True)

    cvd_mix = [w_spot * s + w_perp * p
               for s, p in zip(cvd_spot, cvd_perp)]

    # === 3. EMAå¹³æ»‘ï¼ˆ12å‘¨æœŸâ‰ˆ1hï¼‰===
    cvd_smooth = ema(cvd_mix, period=12)

    # === 4. z-scoreæ ‡å‡†åŒ– ===
    z_cvd = z_score(cvd_smooth[-1], cvd_smooth[-60:])

    # === 5. å¯é€‰ï¼šè·¨äº¤æ˜“æ‰€éªŒè¯ ===
    if use_cross_exchange and symbol in ['BTCUSDT', 'ETHUSDT']:
        cvd_okx = get_cvd_okx(symbol)
        cvd_bybit = get_cvd_bybit(symbol)

        # ä¸€è‡´æ€§æ£€æŸ¥
        consistency = (np.sign(cvd_smooth[-1]) ==
                       np.sign(cvd_okx) ==
                       np.sign(cvd_bybit))

        if not consistency:
            z_cvd *= 0.7  # ä¸ä¸€è‡´æ—¶é™æƒ30%

    # === 6. æ˜ å°„åˆ°Â±100 ===
    score = min(100, max(-100, z_cvd * 33.3))  # z=3 â†’ Â±100

    return score
```

**æ–°å¢å‚æ•°**:
- `cvd_ema_period`: 12
- `cvd_zscore_window`: 60
- `cvd_cross_exchange_enabled`: falseï¼ˆå¯é€‰ï¼‰

##### 6. O+ - OI Regimeï¼ˆå¢å¼ºï¼Œæƒé‡20ï¼‰
```python
# æ•´åˆ #4 OIå››è±¡é™
def calculate_oi_regime(oi_hist, price_hist):
    """
    OIå››è±¡é™ä½“åˆ¶è¯†åˆ«

    æ•´åˆ:
    - åŸæœ‰: ç®€å•OIå˜åŒ–ç‡
    - æ–°å¢: å››è±¡é™åˆ†ç±» + å¼ºåº¦è¯„åˆ†

    Range: -100 åˆ° +100
    """
    # === 1. è®¡ç®—1hå˜åŒ–ç‡ ===
    delta_price_1h = (price_hist[-1] - price_hist[-12]) / price_hist[-12]
    delta_oi_1h = (oi_hist[-1] - oi_hist[-12]) / oi_hist[-12]

    # === 2. å››è±¡é™åˆ¤å®š ===
    if delta_price_1h > 0 and delta_oi_1h > 0:
        # up_up: å¤šå¤´åŠ ä»“ï¼ˆå¼ºåŠ¿ï¼‰
        regime = "up_up"
        base_score = +100
        strength = min(1.5, abs(delta_oi_1h) / 0.05)  # OIå¢5%=æ»¡åˆ†

    elif delta_price_1h > 0 and delta_oi_1h < 0:
        # up_dn: ç©ºå¤´æ­¢æŸï¼ˆå¼±åŠ¿åå¼¹ï¼‰
        regime = "up_dn"
        base_score = +30
        strength = 1.0

    elif delta_price_1h < 0 and delta_oi_1h > 0:
        # dn_up: ç©ºå¤´åŠ ä»“ï¼ˆå¼ºåŠ¿ï¼‰
        regime = "dn_up"
        base_score = -100
        strength = min(1.5, abs(delta_oi_1h) / 0.05)

    else:
        # dn_dn: å¤šå¤´æ­¢æŸï¼ˆå¼±åŠ¿ä¸‹è·Œï¼‰
        regime = "dn_dn"
        base_score = -30
        strength = 1.0

    # === 3. å¼ºåº¦è°ƒæ•´ ===
    score = base_score * strength

    # === 4. é¢å¤–ï¼šOIç»å¯¹å€¼æ°´å¹³è°ƒæ•´ ===
    oi_level = oi_hist[-1] / np.mean(oi_hist[-168:])  # vs 1å‘¨å‡å€¼
    if oi_level > 1.3:  # OIè¿‡é«˜ï¼ˆæ æ†æ‹¥æŒ¤ï¼‰
        score *= 0.85  # é™æƒ15%

    return max(-100, min(100, score)), regime
```

**æ–°å¢å‚æ•°**:
- `oi_regime_window_hours`: 12
- `oi_regime_delta_threshold`: 0.05
- `oi_level_high_threshold`: 1.3

##### 7. F - Fund Leadingï¼ˆä¿ç•™è°ƒèŠ‚å™¨ï¼‰
```python
# ç°æœ‰å®ç°ä¿æŒä¸å˜
def calculate_fund_leading(cvd_data, direction):
    """
    èµ„é‡‘é¢†å…ˆæ€§è°ƒèŠ‚å™¨
    Range: 0.85 ~ 1.15
    """
    # ç°æœ‰é€»è¾‘...
    return adjustment_factor
```

#### **Layer 3: å¾®è§‚ç»“æ„å±‚ï¼ˆ45åˆ†ï¼‰**

##### 8. L - Liquidityï¼ˆæ–°å¢ï¼Œæƒé‡20ï¼‰â­â­â­â­â­
```python
# æ–°å¢ï¼Œæ•´åˆ #2 è®¢å•ç°¿ + #3 LDIï¼ˆå¯é€‰ï¼‰
def calculate_liquidity(symbol, orderbook, use_ldi=False):
    """
    æµåŠ¨æ€§ç»¼åˆè¯„åˆ†

    ç»„æˆ:
    - ç‚¹å·®ï¼ˆ30%ï¼‰
    - æ·±åº¦ï¼ˆ30%ï¼‰
    - å†²å‡»æˆæœ¬ï¼ˆ30%ï¼‰
    - OBIè®¢å•å¤±è¡¡ï¼ˆ10%ï¼‰
    - å¯é€‰: LDIç°¿æŠ½æ°´ï¼ˆåæœŸï¼‰

    Range: 0 åˆ° 100ï¼ˆè´¨é‡ç»´åº¦ï¼Œæ— ç¬¦å·ï¼‰
    """
    mid = (orderbook['bids'][0][0] + orderbook['asks'][0][0]) / 2

    # === 1. ç‚¹å·®è¯„åˆ†ï¼ˆè¶Šå°è¶Šå¥½ï¼‰===
    spread_bps = (orderbook['asks'][0][0] - orderbook['bids'][0][0]) / mid * 10000
    spread_score = 100 if spread_bps < 2 else max(0, 100 - spread_bps * 10)

    # === 2. æ·±åº¦è¯„åˆ†ï¼ˆè¶Šå¤§è¶Šå¥½ï¼‰===
    depth_bid = sum([p * q for p, q in orderbook['bids'][:10]])
    depth_ask = sum([p * q for p, q in orderbook['asks'][:10]])
    depth_total = depth_bid + depth_ask

    depth_score = min(100, depth_total / 1_000_000 * 10)  # 100ä¸‡=100åˆ†

    # === 3. å†²å‡»æˆæœ¬è¯„åˆ†ï¼ˆè¶Šå°è¶Šå¥½ï¼‰===
    impact_pct = calculate_impact(orderbook['asks'], notional=100_000)
    impact_score = max(0, 100 - impact_pct * 10000)  # 1%æ»‘ç‚¹=0åˆ†

    # === 4. OBIè®¢å•å¤±è¡¡ï¼ˆæ— æ–¹å‘ï¼Œåªçœ‹ç»å¯¹å€¼ï¼‰===
    obi = (depth_bid - depth_ask) / (depth_bid + depth_ask + 1e-9)
    obi_score = 100 - abs(obi) * 100  # å¤±è¡¡è¶Šå¤§ï¼Œè´¨é‡è¶Šä½

    # === 5. å¯é€‰ï¼šLDIç°¿æŠ½æ°´æ£€æµ‹ ===
    ldi_penalty = 0
    if use_ldi:
        # ç®€åŒ–ç‰ˆï¼šå¿«ç…§å·®åˆ†æ£€æµ‹å¤§å•æ’¤å•
        ldi = calculate_ldi_simplified(symbol)
        if abs(ldi) > 2.0:  # z-score > 2
            ldi_penalty = 20  # æ‰£20åˆ†

    # === 6. ç»¼åˆè¯„åˆ† ===
    L = (spread_score * 0.3 +
         depth_score * 0.3 +
         impact_score * 0.3 +
         obi_score * 0.1 -
         ldi_penalty)

    return max(0, min(100, L)), {
        'spread_bps': spread_bps,
        'depth_total': depth_total,
        'obi': obi,
        'impact_pct': impact_pct
    }
```

**æ–°å¢å‚æ•°**:
- `liquidity_spread_good_bps`: 2.0
- `liquidity_depth_target_usdt`: 1_000_000
- `liquidity_impact_notional_usdt`: 100_000
- `liquidity_ldi_enabled`: falseï¼ˆå¯é€‰ï¼‰

##### 9. B - Basis+Fundingï¼ˆæ–°å¢ï¼Œæƒé‡15ï¼‰â­â­â­â­
```python
# æ–°å¢ï¼Œæ•´åˆ #5 åŸºå·® + #6 FWIï¼ˆå¯é€‰ï¼‰
def calculate_basis_funding(symbol, use_fwi=False):
    """
    åŸºå·®+èµ„é‡‘è´¹ç»¼åˆè¯„åˆ†

    ç»„æˆ:
    - åŸºå·®ï¼ˆ60%ï¼‰
    - èµ„é‡‘è´¹ï¼ˆ40%ï¼‰
    - å¯é€‰: FWIä¸´çª—æŒ¤å…‘ï¼ˆåæœŸï¼‰

    Range: -100 åˆ° +100
    """
    # === 1. åŸºå·®è®¡ç®— ===
    mark_price = get_mark_price(symbol)
    spot_price = get_spot_ticker(symbol.replace('USDT', '/USDT'))['last']
    basis_bps = (mark_price - spot_price) / spot_price * 10000

    # åŸºå·®è¿‡é«˜ï¼ˆåˆçº¦æº¢ä»·ï¼‰â†’ çœ‹è·Œ
    # åŸºå·®è¿‡ä½ï¼ˆåˆçº¦è´´æ°´ï¼‰â†’ çœ‹æ¶¨
    basis_score = -min(100, max(-100, basis_bps / 0.5))  # Â±50bps=Â±100åˆ†

    # === 2. èµ„é‡‘è´¹è®¡ç®— ===
    funding_rate = get_funding_rate(symbol)  # å¦‚ 0.0001 = 0.01%

    # æ­£èµ„é‡‘è´¹ï¼ˆå¤šå¤´ä»˜ç©ºå¤´ï¼‰â†’ å¤šå¤´æ‹¥æŒ¤ â†’ çœ‹è·Œ
    # è´Ÿèµ„é‡‘è´¹ï¼ˆç©ºå¤´ä»˜å¤šå¤´ï¼‰â†’ ç©ºå¤´æ‹¥æŒ¤ â†’ çœ‹æ¶¨
    funding_score = -min(100, max(-100, funding_rate / 0.001 * 100))

    # === 3. å¯é€‰ï¼šFWIä¸´çª—æŒ¤å…‘å¢å¼º ===
    fwi_boost = 0
    if use_fwi:
        next_funding_time = get_next_funding_time(symbol)
        minutes_to_funding = (next_funding_time - time.time()) / 60

        # çª—å‡½æ•°ï¼ˆ30åˆ†é’Ÿå†…ç”Ÿæ•ˆï¼‰
        if abs(minutes_to_funding) <= 30:
            window = np.exp(-((minutes_to_funding / 10) ** 2))

            # æ–¹å‘ä¸€è‡´æ€§æ£€æŸ¥
            delta_p_30m = (get_price_now() - get_price_30m_ago()) / get_price_30m_ago()
            delta_oi_30m = (get_oi_now() - get_oi_30m_ago()) / get_oi_30m_ago()

            same_direction = (np.sign(funding_rate) ==
                              np.sign(delta_p_30m) ==
                              np.sign(delta_oi_30m))

            if same_direction:
                # ä¸´çª—æŒ¤å…‘é£é™©é«˜
                fwi_boost = np.sign(funding_rate) * abs(funding_rate) / 0.001 * window * 20

    # === 4. ç»¼åˆè¯„åˆ† ===
    B = basis_score * 0.6 + funding_score * 0.4 + fwi_boost

    return max(-100, min(100, B)), {
        'basis_bps': basis_bps,
        'funding_rate': funding_rate,
        'basis_score': basis_score,
        'funding_score': funding_score
    }
```

**æ–°å¢å‚æ•°**:
- `basis_neutral_bps`: 50
- `funding_neutral_rate`: 0.001
- `fwi_enabled`: falseï¼ˆå¯é€‰ï¼‰
- `fwi_window_minutes`: 30

##### 10. Q - Liquidationï¼ˆæ–°å¢ï¼Œæƒé‡10ï¼‰â­â­â­â­
```python
# æ–°å¢ï¼Œæ•´åˆ #7 æ¸…ç®—å¯†åº¦
def calculate_liquidation(symbol):
    """
    æ¸…ç®—å¯†åº¦å€¾æ–œ

    Range: -100 åˆ° +100
    """
    # === 1. è·å–æœ€è¿‘5åˆ†é’Ÿæ¸…ç®—æ•°æ® ===
    liq_data = get_liquidations(symbol, interval="5m")

    liq_long = sum([liq['qty'] for liq in liq_data if liq['side'] == 'LONG'])
    liq_short = sum([liq['qty'] for liq in liq_data if liq['side'] == 'SHORT'])

    # === 2. z-scoreæ ‡å‡†åŒ–ï¼ˆç›¸å¯¹å†å²ï¼‰===
    liq_hist_long = get_liquidation_history(symbol, side='LONG', hours=1)
    liq_hist_short = get_liquidation_history(symbol, side='SHORT', hours=1)

    z_long = z_score(liq_long, liq_hist_long)
    z_short = z_score(liq_short, liq_hist_short)

    # === 3. LTI: ç©ºå¤´æ¸…ç®—å¤š â†’ çœ‹æ¶¨ï¼Œå¤šå¤´æ¸…ç®—å¤š â†’ çœ‹è·Œ ===
    LTI = (z_short - z_long) * 50

    return max(-100, min(100, LTI)), {
        'liq_long_5m': liq_long,
        'liq_short_5m': liq_short,
        'z_long': z_long,
        'z_short': z_short
    }
```

**æ–°å¢å‚æ•°**:
- `liquidation_interval_minutes`: 5
- `liquidation_zscore_window_hours`: 1

#### **Layer 4: å¸‚åœºç¯å¢ƒå±‚ï¼ˆ10åˆ†ï¼‰**

##### 11. I - Independenceï¼ˆæ›¿æ¢Eï¼Œæƒé‡10ï¼‰â­â­â­â­
```python
# æ›¿æ¢åŸæœ‰Eç»´åº¦ï¼Œæ•´åˆ #9 é¢†æ¶¨å›ä¼ Î²
def calculate_independence(symbol, btc_prices, eth_prices, alt_prices):
    """
    ç‹¬ç«‹æ€§è¯„åˆ†ï¼ˆæ›¿æ¢åŸæœ‰Environmentï¼‰

    åŸæœ‰Eç»´åº¦é—®é¢˜:
    - æ³¢åŠ¨ç‡+ç©ºé—´ç»„åˆæ„ä¹‰ä¸å¤§
    - ä¸T/M/Væœ‰é‡å 

    æ–°Iç»´åº¦ä¼˜åŠ¿:
    - è¯†åˆ«ç‹¬ç«‹è¡Œæƒ… vs è·ŸéšBTC
    - ç‹¬ç«‹æ€§é«˜ â†’ Alphaæœºä¼š
    - ç‹¬ç«‹æ€§ä½ â†’ éœ€è¦BTCç¡®è®¤

    Range: 0 åˆ° 100ï¼ˆè´¨é‡ç»´åº¦ï¼Œæ— ç¬¦å·ï¼‰
    """
    from scipy import stats

    # === 1. è®¡ç®—æ”¶ç›Šç‡ ===
    r_btc = np.diff(np.log(btc_prices))
    r_eth = np.diff(np.log(eth_prices))
    r_alt = np.diff(np.log(alt_prices))

    # === 2. æ»šåŠ¨å›å½’ï¼ˆçª—å£24hï¼‰===
    window = 24
    betas = []

    for i in range(window, len(r_alt)):
        # ç®€åŒ–ï¼šBTC+ETHåˆå¹¶å›å½’
        X = (r_btc[i-window:i] + r_eth[i-window:i]) / 2
        y = r_alt[i-window:i]

        if len(X) > 0 and len(y) > 0:
            slope, _, r_value, _, _ = stats.linregress(X, y)
            betas.append(abs(slope))

    # === 3. Î²ç»¼åˆå¼ºåº¦ ===
    beta_sum = np.mean(betas) if betas else 1.0

    # === 4. ç‹¬ç«‹æ€§è¯„åˆ†ï¼ˆÎ²è¶Šä½ï¼Œç‹¬ç«‹æ€§è¶Šé«˜ï¼‰===
    # Î²=0 â†’ 100åˆ†ï¼ˆå®Œå…¨ç‹¬ç«‹ï¼‰
    # Î²=1.5 â†’ 0åˆ†ï¼ˆé«˜åº¦è·Ÿéšï¼‰
    independence_score = max(0, 100 * (1 - min(1.0, beta_sum / 1.5)))

    return independence_score, beta_sum
```

**æ–°å¢å‚æ•°**:
- `independence_window_hours`: 24
- `independence_beta_threshold`: 1.5

---

## ğŸ“ ç»Ÿä¸€æƒé‡ä½“ç³»

### æƒé‡åˆ†é…åŸåˆ™

**æ€»æƒé‡**: 160åˆ† â†’ å½’ä¸€åŒ–åˆ° Â±100

**å±‚çº§æƒé‡**:
```python
weights = {
    # Layer 1: ä»·æ ¼è¡Œä¸ºå±‚ï¼ˆ40.6%ï¼‰
    'T': 25,   # 15.6%  æ ¸å¿ƒè¶‹åŠ¿
    'M': 15,   # 9.4%   åŠ¨é‡
    'S': 10,   # 6.3%   ç»“æ„
    'V+': 15,  # 9.4%   é‡èƒ½+è§¦å‘K

    # Layer 2: èµ„é‡‘æµå±‚ï¼ˆ25.0%ï¼‰
    'C+': 20,  # 12.5%  å¢å¼ºCVD
    'O+': 20,  # 12.5%  OIå››è±¡é™
    # F: è°ƒèŠ‚å™¨ï¼ˆä¸å æƒé‡ï¼‰

    # Layer 3: å¾®è§‚ç»“æ„å±‚ï¼ˆ28.1%ï¼‰
    'L': 20,   # 12.5%  æµåŠ¨æ€§ï¼ˆæ–°å¢ï¼‰â­â­â­â­â­
    'B': 15,   # 9.4%   åŸºå·®+èµ„é‡‘è´¹ï¼ˆæ–°å¢ï¼‰â­â­â­â­
    'Q': 10,   # 6.3%   æ¸…ç®—å¯†åº¦ï¼ˆæ–°å¢ï¼‰â­â­â­â­

    # Layer 4: å¸‚åœºç¯å¢ƒå±‚ï¼ˆ6.3%ï¼‰
    'I': 10,   # 6.3%   ç‹¬ç«‹æ€§ï¼ˆæ›¿æ¢Eï¼‰â­â­â­â­
}

# æ€»è®¡: 160åˆ†
```

### æƒé‡å½’ä¸€åŒ–

```python
def normalize_score(weighted_sum):
    """
    å½’ä¸€åŒ–åˆ°Â±100

    weighted_sumèŒƒå›´: -160 åˆ° +160
    å½’ä¸€åŒ–: weighted_sum / 160 * 100
    """
    return weighted_sum / 1.6  # ç­‰ä»·äº / 160 * 100
```

### è‡ªé€‚åº”æƒé‡ï¼ˆå¯é€‰ï¼‰

```python
# åŸºäºå¸‚åœºä½“åˆ¶åŠ¨æ€è°ƒæ•´æƒé‡
def get_adaptive_weights(market_regime, volatility):
    """
    æ ¹æ®å¸‚åœºçŠ¶æ€è°ƒæ•´æƒé‡

    å¸‚åœºä½“åˆ¶:
    - å¼ºè¶‹åŠ¿ï¼ˆ|regime| > 60ï¼‰: æé«˜T/C+/O+æƒé‡
    - éœ‡è¡å¸‚ï¼ˆ|regime| < 30ï¼‰: æé«˜L/B/Sæƒé‡
    - é«˜æ³¢åŠ¨: æé«˜Qï¼ˆæ¸…ç®—ï¼‰æƒé‡
    """
    base_weights = {...}  # ä¸Šè¿°é»˜è®¤æƒé‡

    if abs(market_regime) > 60:
        # å¼ºè¶‹åŠ¿ï¼šè¶‹åŠ¿å’Œèµ„é‡‘æµæ›´é‡è¦
        adjusted = {
            'T': 30,   # +5
            'C+': 25,  # +5
            'O+': 25,  # +5
            'L': 15,   # -5
            'B': 10,   # -5
            # å…¶ä»–ä¿æŒ
        }
    elif abs(market_regime) < 30:
        # éœ‡è¡å¸‚ï¼šæµåŠ¨æ€§å’Œç»“æ„æ›´é‡è¦
        adjusted = {
            'T': 20,   # -5
            'S': 15,   # +5
            'L': 25,   # +5
            'B': 20,   # +5
            # å…¶ä»–ä¿æŒ
        }
    else:
        adjusted = base_weights

    # é«˜æ³¢åŠ¨ï¼šæé«˜æ¸…ç®—æƒé‡
    if volatility > 0.05:  # æ—¥æ³¢åŠ¨>5%
        adjusted['Q'] = 15  # +5
        adjusted['T'] -= 5

    return adjusted
```

---

## ğŸ”§ ç»Ÿä¸€å‚æ•°ç®¡ç†

### å‚æ•°é…ç½®æ–‡ä»¶ç»“æ„

**æ–°å»º**: `config/factors_unified.json`

```json
{
  "version": "2.0.0",
  "updated_at": "2025-10-27",
  "description": "ç»Ÿä¸€å› å­å‚æ•°é…ç½®ï¼ˆ10+1ç»´ï¼‰",

  "factors": {
    "T": {
      "name": "Trend",
      "weight": 25,
      "enabled": true,
      "params": {
        "ema_short": 10,
        "ema_long": 50,
        "atr_period": 14
      }
    },

    "M": {
      "name": "Momentum",
      "weight": 15,
      "enabled": true,
      "params": {
        "lookback_periods": 20,
        "stable_supply_boost_enabled": false
      }
    },

    "C+": {
      "name": "Enhanced CVD",
      "weight": 20,
      "enabled": true,
      "params": {
        "ema_period": 12,
        "zscore_window": 60,
        "cross_exchange_enabled": false,
        "cross_exchange_symbols": ["BTCUSDT", "ETHUSDT"]
      }
    },

    "S": {
      "name": "Structure",
      "weight": 10,
      "enabled": true,
      "params": {
        "pivot_lookback": 20
      }
    },

    "V+": {
      "name": "Volume + Trigger",
      "weight": 15,
      "enabled": true,
      "params": {
        "volume_zscore_window": 20,
        "trigger_body_ratio_min": 0.6,
        "trigger_breakthrough_atr_mult": 0.25
      }
    },

    "O+": {
      "name": "OI Regime",
      "weight": 20,
      "enabled": true,
      "params": {
        "regime_window_hours": 12,
        "delta_threshold": 0.05,
        "oi_level_high_threshold": 1.3,
        "regime_weights": {
          "up_up": 1.0,
          "up_dn": 0.3,
          "dn_up": -1.0,
          "dn_dn": -0.3
        }
      }
    },

    "L": {
      "name": "Liquidity",
      "weight": 20,
      "enabled": true,
      "params": {
        "spread_good_bps": 2.0,
        "depth_target_usdt": 1000000,
        "impact_notional_usdt": 100000,
        "orderbook_depth_levels": 10,
        "ldi_enabled": false
      }
    },

    "B": {
      "name": "Basis + Funding",
      "weight": 15,
      "enabled": true,
      "params": {
        "basis_neutral_bps": 50,
        "funding_neutral_rate": 0.001,
        "fwi_enabled": false,
        "fwi_window_minutes": 30
      }
    },

    "Q": {
      "name": "Liquidation",
      "weight": 10,
      "enabled": true,
      "params": {
        "interval_minutes": 5,
        "zscore_window_hours": 1
      }
    },

    "I": {
      "name": "Independence",
      "weight": 10,
      "enabled": true,
      "params": {
        "window_hours": 24,
        "beta_threshold": 1.5
      }
    },

    "F": {
      "name": "Fund Leading",
      "type": "regulator",
      "enabled": true,
      "params": {
        "adjustment_range": [0.85, 1.15]
      }
    }
  },

  "adaptive_weights": {
    "enabled": false,
    "regimes": {
      "strong_trend": {
        "condition": "abs(market_regime) > 60",
        "weight_adjustments": {
          "T": 30,
          "C+": 25,
          "O+": 25,
          "L": 15,
          "B": 10
        }
      },
      "choppy": {
        "condition": "abs(market_regime) < 30",
        "weight_adjustments": {
          "T": 20,
          "S": 15,
          "L": 25,
          "B": 20
        }
      },
      "high_volatility": {
        "condition": "volatility > 0.05",
        "weight_adjustments": {
          "Q": 15
        }
      }
    }
  },

  "thresholds": {
    "prime_strength_min": 78,
    "prime_prob_min": 0.62,
    "watch_strength_min": 65,
    "watch_prob_min": 0.55,

    "filters": {
      "liquidity_min": 70,
      "independence_min": 30,
      "basis_extreme_bps": 100,
      "funding_extreme_rate": 0.002,
      "oi_level_max": 1.5
    }
  }
}
```

### å‚æ•°åŠ è½½å™¨

```python
# ats_core/config/factor_config.py
import json
from typing import Dict, Any

class FactorConfig:
    """ç»Ÿä¸€å› å­é…ç½®ç®¡ç†å™¨"""

    def __init__(self, config_path="config/factors_unified.json"):
        with open(config_path, 'r') as f:
            self.config = json.load(f)

        self.version = self.config['version']
        self.factors = self.config['factors']
        self.thresholds = self.config['thresholds']

    def get_factor_params(self, factor_name: str) -> Dict[str, Any]:
        """è·å–å› å­å‚æ•°"""
        if factor_name not in self.factors:
            raise ValueError(f"Unknown factor: {factor_name}")

        return self.factors[factor_name]['params']

    def get_factor_weight(self, factor_name: str) -> int:
        """è·å–å› å­æƒé‡"""
        return self.factors[factor_name]['weight']

    def is_factor_enabled(self, factor_name: str) -> bool:
        """æ£€æŸ¥å› å­æ˜¯å¦å¯ç”¨"""
        return self.factors[factor_name]['enabled']

    def get_all_weights(self) -> Dict[str, int]:
        """è·å–æ‰€æœ‰å› å­æƒé‡"""
        return {
            name: config['weight']
            for name, config in self.factors.items()
            if config['enabled'] and config.get('type') != 'regulator'
        }

    def get_adaptive_weights(self, market_regime: float, volatility: float) -> Dict[str, int]:
        """è·å–è‡ªé€‚åº”æƒé‡"""
        if not self.config['adaptive_weights']['enabled']:
            return self.get_all_weights()

        # å®ç°è‡ªé€‚åº”é€»è¾‘...
        pass

# å…¨å±€å•ä¾‹
_config_instance = None

def get_factor_config() -> FactorConfig:
    global _config_instance
    if _config_instance is None:
        _config_instance = FactorConfig()
    return _config_instance
```

---

## ğŸ›¡ï¸ é˜²è¿‡æ‹Ÿåˆç­–ç•¥

### 1. å› å­æ­£äº¤åŒ–ï¼ˆFactor Orthogonalizationï¼‰

**é—®é¢˜**: 10ä¸ªå› å­å¯èƒ½å­˜åœ¨ç›¸å…³æ€§ â†’ è¿‡æ‹Ÿåˆ

**è§£å†³æ–¹æ¡ˆ**: å®šæœŸè®¡ç®—å› å­ç›¸å…³æ€§çŸ©é˜µï¼Œå‰”é™¤é«˜ç›¸å…³å› å­

```python
# ats_core/evaluation/factor_correlation.py
import numpy as np
import pandas as pd

def calculate_factor_correlation(backtest_results):
    """
    è®¡ç®—å› å­ç›¸å…³æ€§çŸ©é˜µ

    ç›®æ ‡: ä»»æ„ä¸¤å› å­ç›¸å…³æ€§ < 0.5
    """
    factors = ['T', 'M', 'C+', 'S', 'V+', 'O+', 'L', 'B', 'Q', 'I']

    # æ”¶é›†æ‰€æœ‰ä¿¡å·çš„å› å­å€¼
    factor_matrix = []
    for signal in backtest_results:
        factor_values = [signal['factors'][f] for f in factors]
        factor_matrix.append(factor_values)

    # è®¡ç®—ç›¸å…³æ€§çŸ©é˜µ
    df = pd.DataFrame(factor_matrix, columns=factors)
    corr_matrix = df.corr()

    # æ£€æµ‹é«˜ç›¸å…³
    high_corr_pairs = []
    for i in range(len(factors)):
        for j in range(i+1, len(factors)):
            if abs(corr_matrix.iloc[i, j]) > 0.5:
                high_corr_pairs.append((
                    factors[i],
                    factors[j],
                    corr_matrix.iloc[i, j]
                ))

    return corr_matrix, high_corr_pairs

# ä½¿ç”¨ç¤ºä¾‹
corr, high_corr = calculate_factor_correlation(backtest_results)
print("é«˜ç›¸å…³å› å­å¯¹ï¼ˆéœ€è¦è°ƒæ•´ï¼‰:")
for f1, f2, corr_value in high_corr:
    print(f"{f1} <-> {f2}: {corr_value:.3f}")
```

**å¤„ç†ç­–ç•¥**:
- ç›¸å…³æ€§ > 0.7: åˆå¹¶ä¸ºä¸€ä¸ªå› å­
- ç›¸å…³æ€§ 0.5-0.7: è°ƒæ•´å‚æ•°é™ä½ç›¸å…³æ€§
- ç›¸å…³æ€§ < 0.5: ä¿æŒç‹¬ç«‹

### 2. L1/L2æ­£åˆ™åŒ–ï¼ˆRegularizationï¼‰

**æ–¹æ³•**: åœ¨æƒé‡ä¼˜åŒ–æ—¶åŠ å…¥æ­£åˆ™é¡¹ï¼Œæƒ©ç½šè¿‡å¤§æƒé‡

```python
# ats_core/optimization/weight_optimizer.py
from scipy.optimize import minimize

def optimize_weights_with_regularization(backtest_results, lambda_l1=0.01, lambda_l2=0.001):
    """
    å¸¦æ­£åˆ™åŒ–çš„æƒé‡ä¼˜åŒ–

    ç›®æ ‡å‡½æ•°:
    Loss = -Sharpe + Î»1Â·||w||_1 + Î»2Â·||w||_2^2

    çº¦æŸ:
    - Î£w_i = 160
    - w_i >= 0
    """
    def objective(weights):
        # 1. è®¡ç®—Sharpeï¼ˆåŸºäºå›æµ‹ï¼‰
        sharpe = calculate_sharpe_with_weights(backtest_results, weights)

        # 2. L1æ­£åˆ™ï¼ˆç¨€ç–æ€§ï¼‰
        l1_penalty = lambda_l1 * np.sum(np.abs(weights))

        # 3. L2æ­£åˆ™ï¼ˆå¹³æ»‘æ€§ï¼‰
        l2_penalty = lambda_l2 * np.sum(weights ** 2)

        # 4. æ€»æŸå¤±ï¼ˆæœ€å°åŒ–è´ŸSharpeï¼‰
        return -sharpe + l1_penalty + l2_penalty

    # åˆå§‹æƒé‡
    w0 = np.array([25, 15, 20, 10, 15, 20, 20, 15, 10, 10])

    # çº¦æŸæ¡ä»¶
    constraints = [
        {'type': 'eq', 'fun': lambda w: np.sum(w) - 160},  # æ€»å’Œ=160
    ]

    bounds = [(0, 50) for _ in range(10)]  # æ¯ä¸ªæƒé‡0-50

    # ä¼˜åŒ–
    result = minimize(objective, w0, method='SLSQP',
                      bounds=bounds, constraints=constraints)

    return result.x
```

### 3. äº¤å‰éªŒè¯ï¼ˆCross-Validationï¼‰

**æ–¹æ³•**: æ—¶é—´åºåˆ—äº¤å‰éªŒè¯ï¼Œé¿å…æœªæ¥æ•°æ®æ³„éœ²

```python
# ats_core/evaluation/cross_validation.py

def time_series_cross_validation(data, n_splits=5):
    """
    æ—¶é—´åºåˆ—äº¤å‰éªŒè¯

    ç¤ºä¾‹ï¼ˆ5æŠ˜ï¼‰:
    Fold 1: Train[0:20%], Test[20%:40%]
    Fold 2: Train[0:40%], Test[40%:60%]
    Fold 3: Train[0:60%], Test[60%:80%]
    Fold 4: Train[0:80%], Test[80%:100%]
    Fold 5: Train[20%:80%], Test[80%:100%]ï¼ˆæ»šåŠ¨çª—å£ï¼‰
    """
    n = len(data)
    fold_size = n // n_splits

    folds = []
    for i in range(n_splits):
        train_end = (i + 1) * fold_size
        test_start = train_end
        test_end = min(test_start + fold_size, n)

        train_data = data[:train_end]
        test_data = data[test_start:test_end]

        folds.append((train_data, test_data))

    return folds

# ä½¿ç”¨ç¤ºä¾‹
def validate_factor_system(historical_data):
    folds = time_series_cross_validation(historical_data, n_splits=5)

    sharpe_scores = []
    for train, test in folds:
        # 1. åœ¨è®­ç»ƒé›†ä¸Šä¼˜åŒ–æƒé‡
        optimal_weights = optimize_weights_with_regularization(train)

        # 2. åœ¨æµ‹è¯•é›†ä¸ŠéªŒè¯
        test_sharpe = calculate_sharpe_with_weights(test, optimal_weights)
        sharpe_scores.append(test_sharpe)

    print(f"äº¤å‰éªŒè¯Sharpeå‡å€¼: {np.mean(sharpe_scores):.3f}")
    print(f"äº¤å‰éªŒè¯Sharpeæ ‡å‡†å·®: {np.std(sharpe_scores):.3f}")

    # æ ‡å‡†å·®è¿‡å¤§ â†’ è¿‡æ‹Ÿåˆ
    if np.std(sharpe_scores) > 0.2:
        print("âš ï¸ è­¦å‘Šï¼šSharpeæ ‡å‡†å·®è¿‡å¤§ï¼Œå¯èƒ½å­˜åœ¨è¿‡æ‹Ÿåˆï¼")
```

### 4. æ ·æœ¬å¤–éªŒè¯ï¼ˆOut-of-Sampleï¼‰

**æ–¹æ³•**: æ°¸ä¹…é¢„ç•™20%æœ€æ–°æ•°æ®ä½œä¸ºæ ·æœ¬å¤–æµ‹è¯•é›†

```python
# ats_core/evaluation/out_of_sample.py

class OutOfSampleValidator:
    """æ ·æœ¬å¤–éªŒè¯å™¨"""

    def __init__(self, test_ratio=0.2):
        self.test_ratio = test_ratio
        self.oos_start_date = None

    def split_data(self, data):
        """
        åˆ’åˆ†è®­ç»ƒé›†å’Œæ ·æœ¬å¤–æµ‹è¯•é›†

        æ³¨æ„: æµ‹è¯•é›†æ°¸ä¸å‚ä¸è®­ç»ƒï¼
        """
        n = len(data)
        split_idx = int(n * (1 - self.test_ratio))

        train = data[:split_idx]
        test = data[split_idx:]

        self.oos_start_date = test[0]['timestamp']

        return train, test

    def validate(self, train_data, test_data, weights):
        """
        æ ·æœ¬å¤–éªŒè¯

        è¦æ±‚:
        - è®­ç»ƒé›†Sharpe >= 0.8
        - æµ‹è¯•é›†Sharpe >= 0.6
        - è¡°å‡ç‡ < 30%
        """
        train_sharpe = calculate_sharpe_with_weights(train_data, weights)
        test_sharpe = calculate_sharpe_with_weights(test_data, weights)

        decay_rate = (train_sharpe - test_sharpe) / train_sharpe

        print(f"è®­ç»ƒé›†Sharpe: {train_sharpe:.3f}")
        print(f"æµ‹è¯•é›†Sharpe: {test_sharpe:.3f}")
        print(f"è¡°å‡ç‡: {decay_rate:.1%}")

        # åˆ¤å®šæ ‡å‡†
        if test_sharpe < 0.6:
            print("âŒ æ ·æœ¬å¤–éªŒè¯å¤±è´¥ï¼šæµ‹è¯•é›†Sharpeè¿‡ä½")
            return False

        if decay_rate > 0.3:
            print("âš ï¸ è­¦å‘Šï¼šè¡°å‡ç‡è¿‡é«˜ï¼Œå¯èƒ½è¿‡æ‹Ÿåˆ")
            return False

        print("âœ… æ ·æœ¬å¤–éªŒè¯é€šè¿‡")
        return True
```

### 5. å› å­ICç›‘æ§ï¼ˆInformation Coefficientï¼‰

**æ–¹æ³•**: æŒç»­ç›‘æ§å› å­é¢„æµ‹èƒ½åŠ›

```python
# ats_core/evaluation/factor_ic.py

def calculate_factor_ic(factor_values, future_returns):
    """
    è®¡ç®—å› å­ICï¼ˆä¿¡æ¯ç³»æ•°ï¼‰

    IC = Corr(factor_t, return_t+1)

    å¥½å› å­æ ‡å‡†:
    - ICå‡å€¼ > 0.05
    - ICèƒœç‡ > 55%
    - ICç¨³å®šæ€§ï¼ˆstd/meanï¼‰< 2.0
    """
    from scipy.stats import spearmanr

    ic_values = []
    for i in range(len(factor_values) - 1):
        ic, _ = spearmanr(factor_values[i], future_returns[i+1])
        ic_values.append(ic)

    ic_mean = np.mean(ic_values)
    ic_std = np.std(ic_values)
    ic_win_rate = sum([1 for ic in ic_values if ic > 0]) / len(ic_values)
    ic_stability = ic_std / abs(ic_mean) if ic_mean != 0 else 999

    return {
        'ic_mean': ic_mean,
        'ic_std': ic_std,
        'ic_win_rate': ic_win_rate,
        'ic_stability': ic_stability,
        'is_good_factor': (
            ic_mean > 0.05 and
            ic_win_rate > 0.55 and
            ic_stability < 2.0
        )
    }

# ä½¿ç”¨ç¤ºä¾‹
def monitor_all_factors(historical_data):
    """ç›‘æ§æ‰€æœ‰å› å­IC"""
    factors = ['T', 'M', 'C+', 'S', 'V+', 'O+', 'L', 'B', 'Q', 'I']

    for factor_name in factors:
        factor_values = [signal['factors'][factor_name] for signal in historical_data]
        future_returns = [signal['return_1h'] for signal in historical_data]

        ic_stats = calculate_factor_ic(factor_values, future_returns)

        print(f"\n{factor_name} å› å­ICç»Ÿè®¡:")
        print(f"  ICå‡å€¼: {ic_stats['ic_mean']:.4f}")
        print(f"  ICèƒœç‡: {ic_stats['ic_win_rate']:.1%}")
        print(f"  ICç¨³å®šæ€§: {ic_stats['ic_stability']:.2f}")
        print(f"  æ˜¯å¦åˆæ ¼: {'âœ…' if ic_stats['is_good_factor'] else 'âŒ'}")
```

---

## ğŸ”„ å…¨æµç¨‹æ•´åˆ

### å®Œæ•´æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ç»Ÿä¸€åˆ†ææµç¨‹                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 1: Universe Selectionï¼ˆå€™é€‰æ± ï¼‰
â”œâ”€ Elite Poolï¼ˆ24hç¼“å­˜ï¼‰
â”‚  â”œâ”€ æµåŠ¨æ€§è¿‡æ»¤ï¼ˆL > 60ï¼‰      â† æ•´åˆ #2
â”‚  â”œâ”€ åŸºå·®è¿‡æ»¤ï¼ˆ|B| < 100bpsï¼‰  â† æ•´åˆ #5
â”‚  â””â”€ ç‹¬ç«‹æ€§è¿‡æ»¤ï¼ˆI > 20ï¼‰      â† æ•´åˆ #9
â””â”€ Overlay Poolï¼ˆ1hç¼“å­˜ï¼‰
   â”œâ”€ å¼‚å¸¸æ£€æµ‹
   â””â”€ æ–°å¸å¿«é€Ÿé€šé“

â†“

Step 2: Factor Calculationï¼ˆå› å­è®¡ç®—ï¼‰
â”œâ”€ Layer 1: ä»·æ ¼è¡Œä¸ºå±‚
â”‚  â”œâ”€ T: Trendï¼ˆä¿ç•™ï¼‰
â”‚  â”œâ”€ M: Momentumï¼ˆä¿ç•™ï¼‰
â”‚  â”œâ”€ S: Structureï¼ˆä¿ç•™ï¼‰
â”‚  â””â”€ V+: Volume+Triggerï¼ˆå¢å¼ºï¼‰    â† æ•´åˆ #12
â”‚
â”œâ”€ Layer 2: èµ„é‡‘æµå±‚
â”‚  â”œâ”€ C+: Enhanced CVDï¼ˆå¢å¼ºï¼‰      â† æ•´åˆ #1
â”‚  â”œâ”€ O+: OI Regimeï¼ˆå¢å¼ºï¼‰         â† æ•´åˆ #4
â”‚  â””â”€ F: Fund Leadingï¼ˆè°ƒèŠ‚å™¨ï¼‰
â”‚
â”œâ”€ Layer 3: å¾®è§‚ç»“æ„å±‚
â”‚  â”œâ”€ L: Liquidityï¼ˆæ–°å¢ï¼‰          â† æ•´åˆ #2
â”‚  â”œâ”€ B: Basis+Fundingï¼ˆæ–°å¢ï¼‰      â† æ•´åˆ #5
â”‚  â””â”€ Q: Liquidationï¼ˆæ–°å¢ï¼‰        â† æ•´åˆ #7
â”‚
â””â”€ Layer 4: å¸‚åœºç¯å¢ƒå±‚
   â””â”€ I: Independenceï¼ˆæ›¿æ¢Eï¼‰      â† æ•´åˆ #9

â†“

Step 3: Score Calculationï¼ˆè¯„åˆ†ï¼‰
â”œâ”€ åŠ è½½æƒé‡ï¼ˆconfig/factors_unified.jsonï¼‰
â”œâ”€ å¯é€‰ï¼šè‡ªé€‚åº”æƒé‡ï¼ˆåŸºäºå¸‚åœºä½“åˆ¶ï¼‰
â”œâ”€ åŠ æƒæ±‚å’Œ: weighted_score = Î£(score_i Ã— w_i)
â””â”€ å½’ä¸€åŒ–: edge = weighted_score / 160

â†“

Step 4: Probability Mappingï¼ˆæ¦‚ç‡æ˜ å°„ï¼‰
â”œâ”€ Sigmoidæ˜ å°„ï¼ˆå·²ä¼˜åŒ–ï¼‰
â”œâ”€ Fè°ƒèŠ‚å™¨è°ƒæ•´
â””â”€ è´å¶æ–¯å…ˆéªŒæ•´åˆï¼ˆGoldæ–¹æ¡ˆï¼‰

â†“

Step 5: Risk Managementï¼ˆé£é™©ç®¡ç†ï¼‰
â”œâ”€ åŠ¨æ€æ­¢æŸï¼ˆåŸºäºLæµåŠ¨æ€§ï¼‰       â† æ•´åˆ #2
â”œâ”€ æ¸…ç®—å¢™æ­¢ç›ˆï¼ˆåŸºäºQæ¸…ç®—å¯†åº¦ï¼‰   â† æ•´åˆ #7
â””â”€ åŸºå·®è°ƒæ•´ï¼ˆåŸºäºBï¼‰             â† æ•´åˆ #5

â†“

Step 6: Publishing Filterï¼ˆå‘å¸ƒè¿‡æ»¤ï¼‰
â”œâ”€ Primeé˜ˆå€¼ï¼ˆstrength>=78, prob>=62%ï¼‰
â”œâ”€ æµåŠ¨æ€§é—¨æ§›ï¼ˆL >= 70ï¼‰         â† æ•´åˆ #2
â”œâ”€ OBIéªŒè¯ï¼ˆè®¢å•ç°¿æ–¹å‘ä¸€è‡´ï¼‰     â† æ•´åˆ #2
â”œâ”€ åŸºå·®æå€¼è¿‡æ»¤ï¼ˆ|basis| < 100bpsï¼‰â† æ•´åˆ #5
â”œâ”€ èµ„é‡‘è´¹è°ƒæ•´ï¼ˆæå€¼æ‰“æŠ˜ï¼‰        â† æ•´åˆ #5
â””â”€ æ¸…ç®—å¢™è·ç¦»ï¼ˆ> 1%ï¼‰            â† æ•´åˆ #7

â†“

Step 7: Signal Outputï¼ˆä¿¡å·è¾“å‡ºï¼‰
â””â”€ å‘å¸ƒåˆ°Telegram
```

### æ ¸å¿ƒä»£ç æ•´åˆ

```python
# ats_core/pipeline/analyze_symbol_v2.py

from ats_core.config.factor_config import get_factor_config
from ats_core.factors import *  # æ‰€æœ‰å› å­æ¨¡å—

def analyze_symbol_unified(symbol: str, elite_meta: Dict = None) -> Dict:
    """
    ç»Ÿä¸€åˆ†ææµç¨‹ï¼ˆ10+1ç»´å› å­ä½“ç³»ï¼‰

    Returns:
        {
            'symbol': str,
            'factors': {
                'T': float,
                'M': float,
                'C+': float,
                'S': float,
                'V+': float,
                'O+': float,
                'L': float,
                'B': float,
                'Q': float,
                'I': float
            },
            'weighted_score': float,  # -160 ~ +160
            'edge': float,  # -100 ~ +100
            'probability': float,  # 0 ~ 1
            'prime_strength': float,  # 0 ~ 100
            'direction': str,  # 'LONG' / 'SHORT'
            'publish': {
                'prime': bool,
                'watch': bool
            },
            'risk_management': {...},
            'metadata': {...}
        }
    """
    # === 1. åŠ è½½é…ç½® ===
    config = get_factor_config()

    # === 2. è·å–æ•°æ® ===
    klines_1h = get_klines(symbol, "1h", 200)
    klines_4h = get_klines(symbol, "4h", 100)
    oi_hist = get_open_interest_hist(symbol, "1h", 200)
    klines_spot = get_spot_klines(symbol, "1h", 200)

    # å¾®è§‚ç»“æ„æ•°æ®
    orderbook = get_orderbook_snapshot(symbol, depth=20)
    mark_price = get_mark_price(symbol)
    spot_price = get_spot_ticker(symbol)['last']
    funding_rate = get_funding_rate(symbol)
    liquidations = get_liquidations(symbol, interval="5m")

    # å¸‚åœºç¯å¢ƒæ•°æ®
    btc_prices = get_klines('BTCUSDT', '1h', 200)
    eth_prices = get_klines('ETHUSDT', '1h', 200)

    # === 3. è®¡ç®—å› å­ ===
    factors = {}

    # Layer 1: ä»·æ ¼è¡Œä¸ºå±‚
    if config.is_factor_enabled('T'):
        factors['T'] = calculate_trend(klines_1h, klines_4h)

    if config.is_factor_enabled('M'):
        factors['M'] = calculate_momentum(klines_1h)

    if config.is_factor_enabled('S'):
        factors['S'] = calculate_structure(klines_4h)

    if config.is_factor_enabled('V+'):
        support_levels, resistance_levels = extract_sr_levels(klines_4h)
        factors['V+'] = calculate_volume_enhanced(
            klines_1h, support_levels, resistance_levels
        )

    # Layer 2: èµ„é‡‘æµå±‚
    if config.is_factor_enabled('C+'):
        factors['C+'] = calculate_cvd_enhanced(
            symbol, klines_1h, klines_spot,
            use_cross_exchange=config.get_factor_params('C+')['cross_exchange_enabled']
        )

    if config.is_factor_enabled('O+'):
        close_prices = [k[4] for k in klines_1h]
        factors['O+'], oi_regime = calculate_oi_regime(oi_hist, close_prices)

    # Layer 3: å¾®è§‚ç»“æ„å±‚
    if config.is_factor_enabled('L'):
        factors['L'], liq_meta = calculate_liquidity(
            symbol, orderbook,
            use_ldi=config.get_factor_params('L')['ldi_enabled']
        )

    if config.is_factor_enabled('B'):
        factors['B'], basis_meta = calculate_basis_funding(
            symbol,
            use_fwi=config.get_factor_params('B')['fwi_enabled']
        )

    if config.is_factor_enabled('Q'):
        factors['Q'], liq_meta = calculate_liquidation(symbol)

    # Layer 4: å¸‚åœºç¯å¢ƒå±‚
    if config.is_factor_enabled('I'):
        alt_prices = [k[4] for k in klines_1h]
        btc_close = [k[4] for k in btc_prices]
        eth_close = [k[4] for k in eth_prices]
        factors['I'], beta = calculate_independence(
            symbol, btc_close, eth_close, alt_prices
        )

    # === 4. è®¡ç®—åŠ æƒåˆ†æ•° ===
    # è·å–æƒé‡ï¼ˆå¯é€‰è‡ªé€‚åº”ï¼‰
    market_regime, _ = calculate_market_regime()
    volatility = calculate_volatility(klines_1h)

    if config.config['adaptive_weights']['enabled']:
        weights = config.get_adaptive_weights(market_regime, volatility)
    else:
        weights = config.get_all_weights()

    # åŠ æƒæ±‚å’Œ
    weighted_score = sum([
        factors[f] * weights[f] / 100.0  # å½’ä¸€åŒ–
        for f in factors.keys()
        if f in weights
    ])

    # å½’ä¸€åŒ–åˆ°Â±100
    edge = weighted_score / 1.6

    # === 5. æ¦‚ç‡æ˜ å°„ ===
    direction = 'LONG' if edge > 0 else 'SHORT'

    # Sigmoidæ˜ å°„ï¼ˆå·²ä¼˜åŒ–ï¼‰
    prior = elite_meta['prior_up'] if elite_meta else 0.5
    temperature = get_adaptive_temperature(market_regime, volatility)
    Q = elite_meta['Q'] if elite_meta else 1.0

    P_base = map_probability_sigmoid(edge, prior, Q, temperature)

    # Fè°ƒèŠ‚å™¨
    if config.is_factor_enabled('F'):
        F_adjustment = calculate_fund_leading_adjustment(factors['C+'], direction)
        P_final = P_base * F_adjustment
    else:
        P_final = P_base

    # === 6. Primeè¯„åˆ† ===
    prime_strength = abs(edge)  # 0-100

    # === 7. é£é™©ç®¡ç† ===
    entry_price = klines_1h[-1][4]
    atr = calculate_atr(klines_1h)

    # åŠ¨æ€æ­¢æŸï¼ˆåŸºäºæµåŠ¨æ€§ï¼‰
    if factors['L'] < 60:
        sl_multiplier = 2.5
    elif factors['L'] < 80:
        sl_multiplier = 2.0
    else:
        sl_multiplier = 1.8

    if direction == 'LONG':
        stop_loss = entry_price - atr * sl_multiplier
    else:
        stop_loss = entry_price + atr * sl_multiplier

    # æ¸…ç®—å¢™æ­¢ç›ˆ
    liq_walls = detect_liquidation_walls(symbol, liquidations)
    if direction == 'LONG':
        nearest_wall = min([w for w in liq_walls if w > entry_price], default=None)
        if nearest_wall:
            take_profit_1 = nearest_wall * 0.98
        else:
            take_profit_1 = entry_price + atr * 2.5
    else:
        nearest_wall = max([w for w in liq_walls if w < entry_price], default=None)
        if nearest_wall:
            take_profit_1 = nearest_wall * 1.02
        else:
            take_profit_1 = entry_price - atr * 2.5

    # åŸºå·®è°ƒæ•´
    if abs(basis_meta['basis_bps']) > 50:
        take_profit_1 *= 0.9

    # === 8. å‘å¸ƒè¿‡æ»¤ ===
    thresholds = config.thresholds

    # åŸºç¡€é˜ˆå€¼
    pass_basic = (
        prime_strength >= thresholds['prime_strength_min'] and
        P_final >= thresholds['prime_prob_min']
    )

    # æµåŠ¨æ€§è¿‡æ»¤
    pass_liquidity = factors['L'] >= thresholds['filters']['liquidity_min']

    # OBIéªŒè¯
    obi = liq_meta['obi']
    pass_obi = (
        (direction == 'LONG' and obi > 0.1) or
        (direction == 'SHORT' and obi < -0.1)
    )

    # åŸºå·®æå€¼è¿‡æ»¤
    pass_basis = abs(basis_meta['basis_bps']) < thresholds['filters']['basis_extreme_bps']

    # èµ„é‡‘è´¹æå€¼è°ƒæ•´
    if abs(funding_rate) > thresholds['filters']['funding_extreme_rate']:
        P_final *= 0.85
        prime_strength *= 0.9

    # æ¸…ç®—å¢™è·ç¦»
    pass_liq_wall = all([
        abs(wall - entry_price) / entry_price >= 0.01
        for wall in liq_walls
    ])

    # ç»¼åˆåˆ¤å®š
    publish_prime = all([
        pass_basic,
        pass_liquidity,
        pass_obi,
        pass_basis,
        pass_liq_wall
    ])

    publish_watch = prime_strength >= thresholds['watch_strength_min']

    # === 9. è¿”å›ç»“æœ ===
    return {
        'symbol': symbol,
        'timestamp': int(time.time()),

        'factors': factors,
        'weights': weights,
        'weighted_score': weighted_score,
        'edge': edge,

        'probability': P_final,
        'prime_strength': prime_strength,
        'direction': direction,

        'publish': {
            'prime': publish_prime,
            'watch': publish_watch
        },

        'risk_management': {
            'entry': entry_price,
            'stop_loss': stop_loss,
            'take_profit_1': take_profit_1,
            'take_profit_2': take_profit_1 * 1.5,
            'sl_multiplier': sl_multiplier,
            'liquidation_walls': liq_walls
        },

        'metadata': {
            'liquidity': liq_meta,
            'basis': basis_meta,
            'oi_regime': oi_regime,
            'independence_beta': beta,
            'market_regime': market_regime,
            'volatility': volatility,
            'filter_reasons': {
                'pass_basic': pass_basic,
                'pass_liquidity': pass_liquidity,
                'pass_obi': pass_obi,
                'pass_basis': pass_basis,
                'pass_liq_wall': pass_liq_wall
            }
        }
    }
```

---

## ğŸ“… å®æ–½è·¯çº¿å›¾

### Phase 1: æ ¸å¿ƒæ•´åˆï¼ˆ2å‘¨ï¼‰

**Week 1: åŸºç¡€æ¶æ„**
- Day 1-2: åˆ›å»ºç»Ÿä¸€é…ç½®ç³»ç»Ÿï¼ˆ`factors_unified.json` + `FactorConfig`ï¼‰
- Day 3-4: é‡æ„ç°æœ‰å› å­æ¨¡å—ï¼ˆæ ‡å‡†åŒ–æ¥å£ï¼‰
- Day 5-7: å®æ–½OIå››è±¡é™ï¼ˆ#4ï¼‰+ è§¦å‘Kï¼ˆ#12ï¼‰

**Week 2: å¾®è§‚ç»“æ„**
- Day 1-3: å®æ–½æµåŠ¨æ€§å› å­Lï¼ˆ#2ï¼Œæœ€é«˜ä¼˜å…ˆçº§ï¼‰
- Day 4-5: å®æ–½åŸºå·®+èµ„é‡‘è´¹Bï¼ˆ#5ï¼‰
- Day 6-7: å®æ–½ç‹¬ç«‹æ€§å› å­Iï¼ˆ#9ï¼Œæ›¿æ¢Eï¼‰

**äº¤ä»˜ç‰©**:
- âœ… ç»Ÿä¸€é…ç½®ç³»ç»Ÿ
- âœ… 6ä¸ªå› å­å®Œæˆï¼ˆO+, V+, L, B, I, ä¿ç•™T/M/C/S/Fï¼‰
- âœ… åˆæ­¥é˜²è¿‡æ‹Ÿåˆï¼ˆå› å­æ­£äº¤æ£€æŸ¥ï¼‰

### Phase 2: é«˜çº§æ•´åˆï¼ˆ2å‘¨ï¼‰

**Week 3: CVDå¢å¼º + æ¸…ç®—**
- Day 1-3: CVDå¢å¼ºC+ï¼ˆ#1ï¼ŒåŠ¨æ€æƒé‡+EMAï¼‰
- Day 4-7: æ¸…ç®—å¯†åº¦Qï¼ˆ#7ï¼Œæ¥å…¥æ¸…ç®—æ•°æ®ï¼‰

**Week 4: å…¨æµç¨‹æµ‹è¯•**
- Day 1-3: å®Œæ•´å›æµ‹ï¼ˆæ ·æœ¬å†…+æ ·æœ¬å¤–ï¼‰
- Day 4-5: å‚æ•°ä¼˜åŒ–ï¼ˆL1/L2æ­£åˆ™åŒ–ï¼‰
- Day 6-7: ç”Ÿäº§éƒ¨ç½²å‡†å¤‡

**äº¤ä»˜ç‰©**:
- âœ… 10ç»´å› å­ä½“ç³»å®Œæ•´
- âœ… å›æµ‹éªŒè¯é€šè¿‡
- âœ… ç”Ÿäº§å°±ç»ª

### Phase 3: å¯é€‰å¢å¼ºï¼ˆæŒ‰éœ€ï¼‰

- #3 LDIï¼ˆæ•´åˆåˆ°Lï¼‰
- #6 FWIï¼ˆæ•´åˆåˆ°Bï¼‰
- #8 è·¨æ‰€CVPï¼ˆæ•´åˆåˆ°C+ï¼‰
- #11 ç¨³å®šå¸ï¼ˆæ•´åˆåˆ°Mï¼‰

---

## ğŸ“Š é¢„æœŸæ•ˆæœ

### å…³é”®æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ | ç°æœ‰ç³»ç»Ÿ | Phase 1å®Œæˆ | Phase 2å®Œæˆ | æå‡ |
|------|---------|-----------|-----------|------|
| **å› å­æ•°é‡** | 7+1ç»´ | 9+1ç»´ | 10+1ç»´ | +43% |
| **ä¿¡å·èƒœç‡** | 51% | 62-66% | 69-74% | **+44%** |
| **Sharpe Ratio** | 0.5 | 0.75 | 1.0 | **+100%** |
| **æœ€å¤§å›æ’¤** | -25% | -18% | -15% | **-40%** |
| **å‡ä¿¡å·ç‡** | 49% | 36% | 28% | **-43%** |
| **å¹´åŒ–æ”¶ç›Š** | 30% | 50% | 65% | **+117%** |

### è¿‡æ‹Ÿåˆé£é™©è¯„ä¼°

| æ£€æµ‹æŒ‡æ ‡ | ç›®æ ‡ | ç›‘æ§æ–¹å¼ |
|---------|------|---------|
| **å› å­ç›¸å…³æ€§** | < 0.5 | å®šæœŸè®¡ç®—ç›¸å…³çŸ©é˜µ |
| **æ ·æœ¬å¤–è¡°å‡** | < 30% | è®­ç»ƒé›† vs æµ‹è¯•é›†Sharpe |
| **ICç¨³å®šæ€§** | < 2.0 | IC_std / IC_mean |
| **å‚æ•°æ•°é‡** | < 50ä¸ª | ç»Ÿä¸€é…ç½®æ–‡ä»¶ç®¡ç† |

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. âœ… **æœ‰æœºæ•´åˆï¼Œéå †ç Œ**: 7ç»´â†’10ç»´ï¼ˆæ§åˆ¶å¤æ‚åº¦ï¼‰
2. âœ… **ç»Ÿä¸€å‚æ•°ç®¡ç†**: å•ä¸€é…ç½®æ–‡ä»¶ + ç‰ˆæœ¬æ§åˆ¶
3. âœ… **é˜²è¿‡æ‹Ÿåˆç­–ç•¥**: æ­£äº¤åŒ– + æ­£åˆ™åŒ– + äº¤å‰éªŒè¯
4. âœ… **å…¨æµç¨‹ä¼˜åŒ–**: é€‰å¸â†’åˆ†æâ†’é£é™©â†’å‘å¸ƒ
5. âœ… **çµæ´»å¯é…ç½®**: å› å­å¯å¼€å…³ + æƒé‡å¯è°ƒæ•´

### ä¸12ä¸ªå¾®è§‚ç»“æ„å› å­çš„æ˜ å°„

| # | å› å­ | å¤„ç†æ–¹å¼ | ä¼˜å…ˆçº§ |
|---|------|---------|--------|
| 1 | åˆæˆCVD | ğŸ”„ å¢å¼ºCâ†’C+ | Phase 2 |
| 2 | è®¢å•ç°¿ | â• æ–°å¢L | Phase 1 â­â­â­â­â­ |
| 3 | LDI | ğŸ”— å¯é€‰æ•´åˆåˆ°L | Phase 3 |
| 4 | OIå››è±¡é™ | ğŸ”„ å¢å¼ºOâ†’O+ | Phase 1 â­â­â­â­â­ |
| 5 | åŸºå·®èµ„é‡‘è´¹ | â• æ–°å¢B | Phase 1 â­â­â­â­ |
| 6 | FWI | ğŸ”— å¯é€‰æ•´åˆåˆ°B | Phase 3 |
| 7 | æ¸…ç®—å¯†åº¦ | â• æ–°å¢Q | Phase 2 â­â­â­â­ |
| 8 | è·¨æ‰€CVP | ğŸ”— å¯é€‰æ•´åˆåˆ°C+ | Phase 3 |
| 9 | é¢†æ¶¨Î² | ğŸ”„ æ›¿æ¢Eâ†’I | Phase 1 â­â­â­â­ |
| 10 | æœŸæƒGamma | âŒ èˆå¼ƒ | - |
| 11 | ç¨³å®šå¸ | ğŸ”— å¯é€‰æ•´åˆåˆ°M | Phase 3 |
| 12 | è§¦å‘K | ğŸ”„ å¢å¼ºVâ†’V+ | Phase 1 â­â­â­â­ |

### æœ€ç»ˆæ¶æ„

**å› å­ä½“ç³»**: 10ç»´ï¼ˆT, M, C+, S, V+, O+, L, B, Q, Iï¼‰+ Fè°ƒèŠ‚å™¨

**åˆ†å±‚è®¾è®¡**:
- Layer 1: ä»·æ ¼è¡Œä¸ºï¼ˆ65åˆ†ï¼‰
- Layer 2: èµ„é‡‘æµï¼ˆ40åˆ†ï¼‰
- Layer 3: å¾®è§‚ç»“æ„ï¼ˆ45åˆ†ï¼‰
- Layer 4: å¸‚åœºç¯å¢ƒï¼ˆ10åˆ†ï¼‰

**å‚æ•°ç®¡ç†**: ç»Ÿä¸€é…ç½® + ç‰ˆæœ¬æ§åˆ¶ + å¯è§†åŒ–ç›‘æ§

**é˜²è¿‡æ‹Ÿåˆ**: 5é‡ä¿éšœï¼ˆæ­£äº¤åŒ–ã€æ­£åˆ™åŒ–ã€äº¤å‰éªŒè¯ã€æ ·æœ¬å¤–ã€ICç›‘æ§ï¼‰

**é¢„æœŸæ•ˆæœ**: èƒœç‡51%â†’74%ï¼ŒSharpe 0.5â†’1.0

---

ğŸ¤– Generated with World-Class System Architecture Design
ğŸ“… Last Updated: 2025-10-27

**ä¸‹ä¸€æ­¥**: å¼€å§‹å®æ–½Phase 1ï¼Ÿ
